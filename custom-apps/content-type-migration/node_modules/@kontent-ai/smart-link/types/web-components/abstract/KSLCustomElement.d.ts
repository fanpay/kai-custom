/**
 * This is a base class for all kontent-smart-link custom elements.
 */
export declare abstract class KSLCustomElement extends HTMLElement {
    private static _template;
    /**
     * Name of the custom element that will be added to the CustomElementRegistry.
     * This name will be used to add a custom element to the page.
     *
     * @type {string}
     */
    static get is(): string;
    /**
     * Template is usually stored in the scope of custom element file, but this does not work with SSR,
     * since `document` is not available on the backend. That is why we are storing the template in a static
     * constructor property and initialize it when we are sure we are in a browser environment.
     *
     * @type {HTMLTemplateElement}
     */
    protected static get template(): HTMLTemplateElement;
    protected constructor();
    /**
     * Add this custom element to the CustomElementRegistry so that it can be used on the page.
     * Usually customElements.define is called inline right at the bottom of the custom element file,
     * but this would not work with SSR, since custom elements can't be defined on the backend.
     */
    static define(): Promise<CustomElementConstructor>;
    /**
     * Initialize a template for the custom element.
     * Each KSL custom element class should implement this static method.
     *
     * @returns {HTMLTemplateElement}
     */
    protected static initializeTemplate(): HTMLTemplateElement;
    /**
     * Update attribute value on the custom element.
     *
     * @param {string} attributeName
     * @param {string | number | boolean | null} attributeValue
     */
    protected updateAttribute(attributeName: string, attributeValue: string | number | boolean | null): void;
    /**
     * Dispatch an asynchronous event from component. Dispatching this event returns Promise
     * which resolves if event was successful and rejects if events is not successful.
     *
     * @param {string} eventType
     * @param {TEventData} eventData
     * @param {number | null} timeout
     * @protected
     */
    protected dispatchAsyncEvent<TEventData, TResolveData, TRejectReason>(eventType: string, eventData: TEventData, timeout?: number | null): Promise<TResolveData>;
}
