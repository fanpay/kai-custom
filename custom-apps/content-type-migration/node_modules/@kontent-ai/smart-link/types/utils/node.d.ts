export declare function groupElementsByRenderingRoot(elements: ReadonlySet<HTMLElement>): Map<HTMLElement | null, ReadonlySet<HTMLElement>>;
/**
 * Iterate through node ancestors and find an element which will be used as a parent for
 * the ksl-container. This element should either be positioned (position is anything except static) or should
 * have its content clipped. In case of table element (td, th, table) it should be positioned or it will be ignored
 * (even if its content is clipped).
 *
 * @param {HTMLElement} element
 * @returns {HTMLElement | null}
 */
export declare function getRenderingRootForElement(element: HTMLElement): HTMLElement | null;
export interface IRenderingRootMetadata {
    readonly isPositioned: boolean;
    readonly isContentClipped: boolean;
}
export declare function getRenderingRootMetadata(root: HTMLElement): IRenderingRootMetadata;
/**
 * Iterate through node ancestors until HTMLElement.offsetParent is reached and sum scroll offsets.
 *
 * @param {HTMLElement | null} node
 * @returns {[number, number]}
 *  where the first number is a totalScrollTop, and the second number is a totalScrollLeft.
 */
export declare function getTotalScrollOffset(node: HTMLElement | null): [number, number];
/**
 * Get all element ancestors.
 * @param {HTMLElement} element
 */
export declare function getElementAncestors(element: HTMLElement): ReadonlyArray<HTMLElement>;
export declare function createTemplateForCustomElement(html: string): HTMLTemplateElement;
