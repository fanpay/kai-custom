"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evaluateOptionallyAsync = exports.mergeOptionalAsyncs = exports.chainOptionallyAsync = exports.applyOnOptionallyAsync = exports.createOptionallyAsync = void 0;
const createOptionallyAsync = (fnc) => ({
    optionallyAsyncFnc: fnc,
});
exports.createOptionallyAsync = createOptionallyAsync;
const applyOnOptionallyAsync = (fnc, transformer) => ({
    optionallyAsyncFnc: (fetchItems) => {
        const input = fnc.optionallyAsyncFnc(fetchItems);
        return input instanceof Promise ? input.then(transformer) : transformer(input);
    },
});
exports.applyOnOptionallyAsync = applyOnOptionallyAsync;
const chainOptionallyAsync = (fnc, chainCall) => flattenOptionallyAsync((0, exports.applyOnOptionallyAsync)(fnc, chainCall));
exports.chainOptionallyAsync = chainOptionallyAsync;
const flattenOptionallyAsync = (nested) => ({
    optionallyAsyncFnc: (fetchItems) => {
        const outerResult = nested.optionallyAsyncFnc(fetchItems);
        const innerResult = outerResult instanceof Promise
            ? outerResult.then((res) => res.optionallyAsyncFnc(fetchItems))
            : outerResult.optionallyAsyncFnc(fetchItems);
        return innerResult;
    },
});
const mergeOptionalAsyncs = (asyncs) => ({
    optionallyAsyncFnc: (fetchItems) => {
        const evaluated = asyncs.map((as) => as.optionallyAsyncFnc(fetchItems));
        const nonPromises = evaluated.filter((e) => !(e instanceof Promise));
        return nonPromises.length === evaluated.length
            ? nonPromises
            : Promise.all(evaluated.map((e) => (e instanceof Promise ? e : Promise.resolve(e))));
    },
});
exports.mergeOptionalAsyncs = mergeOptionalAsyncs;
function evaluateOptionallyAsync(fnc, fetchItems) {
    return fnc.optionallyAsyncFnc(fetchItems !== null && fetchItems !== void 0 ? fetchItems : undefined);
}
exports.evaluateOptionallyAsync = evaluateOptionallyAsync;
//# sourceMappingURL=optionallyAsync.js.map