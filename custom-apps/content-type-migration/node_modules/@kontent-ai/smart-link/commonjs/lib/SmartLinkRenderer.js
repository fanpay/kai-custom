"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartLinkRenderer = void 0;
const node_1 = require("../utils/node");
const KSLContainerElement_1 = require("../web-components/KSLContainerElement");
const customElements_1 = require("../utils/customElements");
class SmartLinkRenderer {
    constructor() {
        this.render = (visibleElements, observedElements) => {
            var _a, _b;
            if (observedElements.size === 0) {
                this.clear();
            }
            else {
                const newAddButtonByElement = new Map();
                const newHighlightByElement = new Map();
                // Group elements by their rendering roots to avoid unnecessary re-calculations (e.g. reposition container only once
                // instead of repositioning it for every child, calculating bounding client rects, etc.).
                const elementsByRenderingRoot = (0, node_1.groupElementsByRenderingRoot)(visibleElements);
                for (const [root, elements] of elementsByRenderingRoot.entries()) {
                    const container = this.createContainerIfNotExist(root);
                    container.adjustPosition();
                    for (const element of elements) {
                        // This check is needed to prevent highlight rendering for the "flat" elements (height or/and width === 0),
                        // because those elements are basically invisible and cannot be clicked.
                        const isFlat = element.offsetHeight === 0 || element.offsetHeight === 0;
                        if (!isFlat && (0, customElements_1.shouldElementHaveHighlight)(element)) {
                            const highlight = (_a = this.highlightByElement.get(element)) !== null && _a !== void 0 ? _a : container.createHighlightForElement(element);
                            highlight.adjustPosition();
                            // We are creating a new highlight by element map to be able to compare it with an old one to find out
                            // which elements have been removed before renders and remove their highlights from the DOM.
                            newHighlightByElement.set(element, highlight);
                            this.highlightByElement.delete(element);
                        }
                        if ((0, customElements_1.shouldElementHaveAddButton)(element)) {
                            const button = (_b = this.addButtonByElement.get(element)) !== null && _b !== void 0 ? _b : container.createAddButtonForElement(element);
                            button.adjustPosition();
                            // We are creating a new add button by element map to be able to compare it with an old one to find out
                            // which elements have been removed before renders and remove their add buttons from the DOM.
                            newAddButtonByElement.set(element, button);
                            this.addButtonByElement.delete(element);
                        }
                    }
                }
                // All highlights that are left in the old highlightByElement map are the remnants of the old render.
                // We check if they are still observed and relevant for the renderer and if not they can be removed.
                for (const [element, highlight] of this.highlightByElement.entries()) {
                    if (!observedElements.has(element)) {
                        highlight.remove();
                        this.highlightByElement.delete(element);
                    }
                    else {
                        newHighlightByElement.set(element, highlight);
                    }
                }
                // All add buttons that are left in the old addButtonByElement map are the remnants of the old render.
                // We check if they are still observed and relevant for the renderer and if not they can be removed.
                for (const [element, addButton] of this.addButtonByElement.entries()) {
                    if (!observedElements.has(element)) {
                        addButton.remove();
                        this.addButtonByElement.delete(element);
                    }
                    else {
                        newAddButtonByElement.set(element, addButton);
                    }
                }
                // All containers that have no children can be removed because they are not used by any highlight, or a add button.
                for (const [parent, container] of this.containerByRenderingRoot.entries()) {
                    if (container.children.length === 0) {
                        container.remove();
                        this.containerByRenderingRoot.delete(parent);
                    }
                }
                this.highlightByElement = newHighlightByElement;
                this.addButtonByElement = newAddButtonByElement;
            }
        };
        this.destroy = () => {
            this.clear();
            this.defaultContainer.remove();
        };
        this.clear = () => {
            for (const [element, addButton] of this.addButtonByElement.entries()) {
                addButton.remove();
                this.addButtonByElement.delete(element);
            }
            for (const [element, highlight] of this.highlightByElement.entries()) {
                highlight.remove();
                this.highlightByElement.delete(element);
            }
            for (const [root, container] of this.containerByRenderingRoot.entries()) {
                container.remove();
                this.containerByRenderingRoot.delete(root);
            }
            this.highlightByElement = new Map();
            this.containerByRenderingRoot = new Map();
            this.addButtonByElement = new Map();
            this.defaultContainer.innerHTML = '';
        };
        this.createContainerIfNotExist = (root) => {
            // if root is not specified or root is body
            if (!root || root === document.body) {
                return this.defaultContainer;
            }
            let container = this.containerByRenderingRoot.get(root);
            if (container) {
                return container;
            }
            container = document.createElement(KSLContainerElement_1.KSLContainerElement.is);
            root.appendChild(container);
            this.containerByRenderingRoot.set(root, container);
            return container;
        };
        this.containerByRenderingRoot = new Map();
        this.highlightByElement = new Map();
        this.addButtonByElement = new Map();
        this.defaultContainer = SmartLinkRenderer.createAndMountDefaultContainer();
    }
    static createAndMountDefaultContainer() {
        const container = document.createElement(KSLContainerElement_1.KSLContainerElement.is);
        window.document.body.appendChild(container);
        return container;
    }
}
exports.SmartLinkRenderer = SmartLinkRenderer;
//# sourceMappingURL=SmartLinkRenderer.js.map