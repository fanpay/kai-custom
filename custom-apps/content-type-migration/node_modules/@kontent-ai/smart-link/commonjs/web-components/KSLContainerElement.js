"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KSLContainerElement = void 0;
const KSLCustomElement_1 = require("./abstract/KSLCustomElement");
const KSLAddButtonElement_1 = require("./KSLAddButtonElement");
const KSLHighlightElement_1 = require("./KSLHighlightElement");
const node_1 = require("../utils/node");
const zIndex_1 = require("./constants/zIndex");
const templateHTML = `
  <style>
    :host {
      display: block;
      position: absolute;
      box-sizing: border-box;
      top: 0;
      right: 0;
      left: 0;
      bottom: 0;
      pointer-events: none;
      touch-action: none;
      z-index: var(--ksl-z-index, ${zIndex_1.BaseZIndex});
    }
    
    :host([clipped]) {
      overflow: hidden;
    }
  </style>
  <slot></slot>
`;
class KSLContainerElement extends KSLCustomElement_1.KSLCustomElement {
    constructor() {
        super(...arguments);
        this._boundingClientRect = null;
        this.createHighlightForElement = (element) => {
            const highlight = document.createElement(KSLHighlightElement_1.KSLHighlightElement.is);
            highlight.attachTo(element);
            this.appendChild(highlight);
            return highlight;
        };
        this.createAddButtonForElement = (element) => {
            const button = document.createElement(KSLAddButtonElement_1.KSLAddButtonElement.is);
            button.attachTo(element);
            this.appendChild(button);
            return button;
        };
        this.adjustPosition = () => {
            const parent = this.parentElement;
            if (!parent) {
                return; // No need to adjust position when element is not mounted.
            }
            const metadata = (0, node_1.getRenderingRootMetadata)(parent);
            if (!metadata.isPositioned) {
                // When parent element is not positioned it means that container
                // will be positioned relatively to some other element. That is why we need
                // to keep in mind all of the scroll offsets on the way to this relative element.
                const [scrollOffsetTop, scrollOffsetLeft] = (0, node_1.getTotalScrollOffset)(parent);
                this.style.height = `${parent.clientHeight}px`;
                this.style.width = `${parent.clientWidth}px`;
                this.style.top = `${parent.offsetTop - scrollOffsetTop}px`;
                this.style.left = `${parent.offsetLeft - scrollOffsetLeft}px`;
                // When parent element is not positioned and its content is clipped
                // we need to hide overflow of the container as well to prevent
                // highlights from appearing for overflown content.
                this.updateAttribute('clipped', Boolean(metadata.isContentClipped));
            }
            this.getBoundingClientRect(true);
        };
    }
    static get is() {
        return 'ksl-container';
    }
    static initializeTemplate() {
        return (0, node_1.createTemplateForCustomElement)(templateHTML);
    }
    getBoundingClientRect(shouldRecompute = false) {
        if (!this._boundingClientRect || shouldRecompute) {
            this._boundingClientRect = super.getBoundingClientRect();
        }
        return this._boundingClientRect;
    }
}
exports.KSLContainerElement = KSLContainerElement;
//# sourceMappingURL=KSLContainerElement.js.map