import { isElementWebComponent } from '../web-components/components';
import { AddButtonElementType, IFrameMessageType, } from './IFrameCommunicatorTypes';
import { SmartLinkRenderer } from './SmartLinkRenderer';
import { getAugmentableDescendants, isElementAugmentable } from '../utils/customElements';
import { validateAddActionMessageData, validateAddInitialMessageData, validateContentComponentClickMessageData, validateContentItemClickEditMessageData, validateElementClickMessageData, } from '../utils/validation';
import { ConfigurationManager } from './ConfigurationManager';
import { buildKontentLink } from '../utils/link';
import { Logger } from './Logger';
import { InvalidEnvironmentError } from '../utils/errors';
export class NodeSmartLinkProvider {
    constructor(iframeCommunicator) {
        this.iframeCommunicator = iframeCommunicator;
        this.enabled = false;
        this.renderingTimeoutId = 0;
        this.observedElements = new Set();
        this.visibleElements = new Set();
        this.toggle = (force) => {
            const shouldEnable = typeof force !== 'undefined' ? force : !this.enabled;
            if (shouldEnable) {
                this.enable();
            }
            else {
                this.disable();
            }
        };
        this.enable = () => {
            if (this.enabled)
                return;
            this.startRenderingInterval();
            this.listenToGlobalEvents();
            this.observeDomMutations();
            this.enabled = true;
        };
        this.disable = () => {
            if (!this.enabled)
                return;
            this.stopRenderingInterval();
            this.unlistenToGlobalEvents();
            this.disconnectObservers();
            this.renderer.clear();
            this.enabled = false;
        };
        this.destroy = () => {
            this.disable();
            this.renderer.destroy();
        };
        this.augmentVisibleElements = () => {
            requestAnimationFrame(() => {
                this.renderer.render(this.visibleElements, this.observedElements);
            });
        };
        /**
         * Start an interval rendering (1s) that will re-render highlights for all visible elements using `setTimeout`.
         * It helps to adjust highlights position even in situations that are currently not supported by
         * the SDK (e.g. element position change w/o animations, some infinite animations and other possible unhandled cases)
         * for better user experience.
         */
        this.startRenderingInterval = () => {
            this.augmentVisibleElements();
            this.renderingTimeoutId = window.setTimeout(this.startRenderingInterval, 1000);
        };
        this.stopRenderingInterval = () => {
            if (this.renderingTimeoutId) {
                clearTimeout(this.renderingTimeoutId);
                this.renderingTimeoutId = 0;
            }
        };
        this.listenToGlobalEvents = () => {
            window.addEventListener('scroll', this.augmentVisibleElements, { capture: true });
            window.addEventListener('resize', this.augmentVisibleElements, { passive: true });
            window.addEventListener('animationend', this.augmentVisibleElements, { passive: true, capture: true });
            window.addEventListener('transitionend', this.augmentVisibleElements, { passive: true, capture: true });
            window.addEventListener('ksl:add-button:initial', this.onAddInitialClick, { capture: true });
            window.addEventListener('ksl:add-button:action', this.onAddActionClick, { capture: true });
            window.addEventListener('ksl:highlight:edit', this.onEditElement, { capture: true });
        };
        this.unlistenToGlobalEvents = () => {
            window.removeEventListener('scroll', this.augmentVisibleElements, { capture: true });
            window.removeEventListener('resize', this.augmentVisibleElements);
            window.removeEventListener('animationend', this.augmentVisibleElements, { capture: true });
            window.removeEventListener('transitionend', this.augmentVisibleElements, { capture: true });
            window.removeEventListener('ksl:add-button:initial', this.onAddInitialClick, { capture: true });
            window.removeEventListener('ksl:add-button:action', this.onAddActionClick, { capture: true });
            window.removeEventListener('ksl:highlight:edit', this.onEditElement, { capture: true });
        };
        this.observeDomMutations = () => {
            if (this.enabled)
                return;
            this.mutationObserver.observe(window.document.body, {
                childList: true,
                subtree: true,
            });
            getAugmentableDescendants(document).forEach((element) => {
                if (element instanceof HTMLElement) {
                    this.observeElementVisibility(element);
                }
            });
        };
        this.disconnectObservers = () => {
            this.mutationObserver.disconnect();
            this.intersectionObserver.disconnect();
            this.observedElements.forEach((element) => {
                this.unobserveElementVisibility(element);
            });
            this.observedElements = new Set();
            this.visibleElements = new Set();
        };
        this.observeElementVisibility = (element) => {
            if (this.observedElements.has(element))
                return;
            this.intersectionObserver.observe(element);
            this.observedElements.add(element);
        };
        this.unobserveElementVisibility = (element) => {
            if (!this.observedElements.has(element))
                return;
            this.intersectionObserver.unobserve(element);
            this.observedElements.delete(element);
            this.visibleElements.delete(element);
        };
        this.onDomMutation = (mutations) => {
            const relevantMutations = mutations.filter((mutation) => {
                const isTypeRelevant = mutation.type === 'childList';
                const isTargetRelevant = mutation.target instanceof HTMLElement && !isElementWebComponent(mutation.target);
                if (!isTypeRelevant || !isTargetRelevant) {
                    return false;
                }
                const hasRelevantAddedNodes = Array.from(mutation.addedNodes).some((node) => node instanceof HTMLElement && !isElementWebComponent(node));
                const hasRelevantRemovedNodes = Array.from(mutation.removedNodes).some((node) => node instanceof HTMLElement && !isElementWebComponent(node));
                return hasRelevantAddedNodes || hasRelevantRemovedNodes;
            });
            for (const mutation of relevantMutations) {
                for (const node of mutation.addedNodes) {
                    if (!(node instanceof HTMLElement))
                        continue;
                    if (isElementAugmentable(node)) {
                        this.observeElementVisibility(node);
                    }
                    for (const element of getAugmentableDescendants(node)) {
                        if (!(element instanceof HTMLElement))
                            continue;
                        this.observeElementVisibility(element);
                    }
                }
                for (const node of mutation.removedNodes) {
                    if (!(node instanceof HTMLElement))
                        continue;
                    if (isElementAugmentable(node)) {
                        this.unobserveElementVisibility(node);
                    }
                    for (const element of getAugmentableDescendants(node)) {
                        if (!(element instanceof HTMLElement))
                            continue;
                        this.unobserveElementVisibility(element);
                    }
                }
            }
            if (relevantMutations.length > 0) {
                this.augmentVisibleElements();
            }
        };
        this.onElementVisibilityChange = (entries) => {
            const filteredEntries = entries.filter((entry) => entry.target instanceof HTMLElement);
            for (const entry of filteredEntries) {
                const target = entry.target;
                if (entry.isIntersecting) {
                    this.visibleElements.add(target);
                }
                else {
                    this.visibleElements.delete(target);
                }
            }
            if (filteredEntries.length > 0) {
                this.augmentVisibleElements();
            }
        };
        this.onEditElement = (event) => {
            var _a, _b;
            const isInsideWebSpotlight = this.configurationManager.isInsideWebSpotlightPreviewIFrame;
            const { data, targetNode } = event.detail;
            const messageData = Object.assign(Object.assign({}, data), { projectId: (_a = data.projectId) !== null && _a !== void 0 ? _a : this.configurationManager.defaultProjectId, languageCodename: (_b = data.languageCodename) !== null && _b !== void 0 ? _b : this.configurationManager.defaultLanguageCodename });
            const messageMetadata = {
                elementRect: targetNode.getBoundingClientRect(),
            };
            if ('elementCodename' in messageData && messageData.elementCodename) {
                if (validateElementClickMessageData(messageData)) {
                    if (isInsideWebSpotlight) {
                        this.iframeCommunicator.sendMessage(IFrameMessageType.ElementClicked, messageData, messageMetadata);
                    }
                    else {
                        const link = buildKontentLink(messageData);
                        window.open(link, '_blank');
                    }
                }
            }
            else if ('contentComponentId' in messageData && messageData.contentComponentId) {
                if (validateContentComponentClickMessageData(messageData)) {
                    if (isInsideWebSpotlight) {
                        this.iframeCommunicator.sendMessage(IFrameMessageType.ContentComponentClicked, messageData, messageMetadata);
                    }
                    else {
                        Logger.warn('Edit buttons for content components are only functional inside Web Spotlight.');
                    }
                }
            }
            else if ('itemId' in messageData && messageData.itemId) {
                if (validateContentItemClickEditMessageData(messageData)) {
                    if (isInsideWebSpotlight) {
                        this.iframeCommunicator.sendMessage(IFrameMessageType.ContentItemClicked, messageData, messageMetadata);
                    }
                    else {
                        Logger.warn('Add buttons for content items are only functional inside Web Spotlight.');
                    }
                }
            }
            else {
                Logger.warn('Some required attributes are not found or the edit button for this type of element is not yet supported.');
            }
        };
        this.onAddInitialClick = (event) => {
            var _a, _b;
            const isInsideWebSpotlight = this.configurationManager.isInsideWebSpotlightPreviewIFrame;
            const { eventData, onResolve, onReject } = event.detail;
            const { data, targetNode } = eventData;
            const messageData = Object.assign(Object.assign({}, data), { languageCodename: (_a = data.languageCodename) !== null && _a !== void 0 ? _a : this.configurationManager.defaultLanguageCodename, projectId: (_b = data.projectId) !== null && _b !== void 0 ? _b : this.configurationManager.defaultProjectId });
            if (validateAddInitialMessageData(messageData)) {
                if (isInsideWebSpotlight) {
                    const messageMetadata = {
                        elementRect: targetNode.getBoundingClientRect(),
                    };
                    this.iframeCommunicator.sendMessageWithResponse(IFrameMessageType.AddInitial, messageData, (response) => {
                        if (!response || response.elementType === AddButtonElementType.Unknown) {
                            return onReject({ message: 'Something went wrong' });
                        }
                        return onResolve(response);
                    }, messageMetadata);
                }
                else {
                    Logger.warn('Add buttons are only functional inside Web Spotlight.');
                    onReject({ message: 'Add buttons are only functional inside Web Spotlight' });
                }
            }
            else {
                onReject({ message: 'Required data attributes are missing' });
            }
        };
        this.onAddActionClick = (event) => {
            var _a, _b;
            const isInsideWebSpotlight = this.configurationManager.isInsideWebSpotlightPreviewIFrame;
            const { data, targetNode } = event.detail;
            const messageData = Object.assign(Object.assign({}, data), { languageCodename: (_a = data.languageCodename) !== null && _a !== void 0 ? _a : this.configurationManager.defaultLanguageCodename, projectId: (_b = data.projectId) !== null && _b !== void 0 ? _b : this.configurationManager.defaultProjectId });
            if (validateAddActionMessageData(messageData)) {
                if (isInsideWebSpotlight) {
                    const messageMetadata = {
                        elementRect: targetNode.getBoundingClientRect(),
                    };
                    this.iframeCommunicator.sendMessage(IFrameMessageType.AddAction, messageData, messageMetadata);
                }
                else {
                    Logger.warn('Add buttons are only functional inside Web Spotlight.');
                }
            }
        };
        if (typeof window === 'undefined' ||
            typeof MutationObserver === 'undefined' ||
            typeof IntersectionObserver === 'undefined') {
            throw InvalidEnvironmentError('NodeSmartLinkProvider can only be initialized in a browser environment.');
        }
        this.configurationManager = ConfigurationManager.getInstance();
        this.mutationObserver = new MutationObserver(this.onDomMutation);
        this.intersectionObserver = new IntersectionObserver(this.onElementVisibilityChange);
        this.renderer = new SmartLinkRenderer();
    }
}
//# sourceMappingURL=NodeSmartLinkProvider.js.map