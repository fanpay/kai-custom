export const createOptionallyAsync = (fnc) => ({
    optionallyAsyncFnc: fnc,
});
export const applyOnOptionallyAsync = (fnc, transformer) => ({
    optionallyAsyncFnc: (fetchItems) => {
        const input = fnc.optionallyAsyncFnc(fetchItems);
        return input instanceof Promise ? input.then(transformer) : transformer(input);
    },
});
export const chainOptionallyAsync = (fnc, chainCall) => flattenOptionallyAsync(applyOnOptionallyAsync(fnc, chainCall));
const flattenOptionallyAsync = (nested) => ({
    optionallyAsyncFnc: (fetchItems) => {
        const outerResult = nested.optionallyAsyncFnc(fetchItems);
        const innerResult = outerResult instanceof Promise
            ? outerResult.then((res) => res.optionallyAsyncFnc(fetchItems))
            : outerResult.optionallyAsyncFnc(fetchItems);
        return innerResult;
    },
});
export const mergeOptionalAsyncs = (asyncs) => ({
    optionallyAsyncFnc: (fetchItems) => {
        const evaluated = asyncs.map((as) => as.optionallyAsyncFnc(fetchItems));
        const nonPromises = evaluated.filter((e) => !(e instanceof Promise));
        return nonPromises.length === evaluated.length
            ? nonPromises
            : Promise.all(evaluated.map((e) => (e instanceof Promise ? e : Promise.resolve(e))));
    },
});
export function evaluateOptionallyAsync(fnc, fetchItems) {
    return fnc.optionallyAsyncFnc(fetchItems !== null && fetchItems !== void 0 ? fetchItems : undefined);
}
//# sourceMappingURL=optionallyAsync.js.map