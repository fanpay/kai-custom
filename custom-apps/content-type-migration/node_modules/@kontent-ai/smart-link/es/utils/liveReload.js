import { camelCasePropertyNameResolver, ElementType, } from '@kontent-ai/delivery-sdk';
import { applyOnOptionallyAsync, evaluateOptionallyAsync, createOptionallyAsync, mergeOptionalAsyncs, chainOptionallyAsync, } from './liveReload/optionallyAsync';
const defaultCodenameResolver = (codename) => camelCasePropertyNameResolver('', codename);
export const applyUpdateOnItem = (item, update, resolveElementCodename = defaultCodenameResolver) => evaluateOptionallyAsync(applyUpdateOnItemOptionallyAsync(item, update, resolveElementCodename), null);
export const applyUpdateOnItemAndLoadLinkedItems = (item, update, fetchItems, resolveElementCodename = defaultCodenameResolver) => evaluateOptionallyAsync(applyUpdateOnItemOptionallyAsync(item, update, resolveElementCodename), fetchItems);
const applyUpdateOnItemOptionallyAsync = (item, update, resolveElementCodename, updatedItem = null, processedItemsPath = []) => {
    const shouldApplyOnThisItem = item.system.codename === update.item.codename && item.system.language === update.variant.codename;
    const elementUpdates = update.elements.map((u) => (Object.assign(Object.assign({}, u), { element: Object.assign(Object.assign({}, u.element), { codename: resolveElementCodename(u.element.codename) }) })));
    const newUpdatedItem = !updatedItem && shouldApplyOnThisItem ? Object.assign({}, item) : updatedItem; // We will mutate its elements to new values before returning. This is necesary to preserve cyclic dependencies between items without infinite recursion.
    const updatedElements = mergeOptionalAsyncs(Object.entries(item.elements).map(([elementCodename, element]) => {
        const matchingUpdate = elementUpdates.find((u) => u.element.codename === elementCodename);
        if (shouldApplyOnThisItem && matchingUpdate) {
            return applyOnOptionallyAsync(applyUpdateOnElement(element, matchingUpdate, resolveElementCodename), (newElement) => [elementCodename, newElement]);
        }
        if (element.type === ElementType.ModularContent || element.type === ElementType.RichText) {
            const typedItemElement = element;
            return applyOnOptionallyAsync(mergeOptionalAsyncs(typedItemElement.linkedItems.map((i) => {
                var _a;
                if ((updatedItem === null || updatedItem === void 0 ? void 0 : updatedItem.system.codename) === i.system.codename) {
                    // we closed the cycle and on the updated item and need to connect to the new item
                    return createOptionallyAsync(() => updatedItem);
                }
                return closesCycleWithoutUpdate(processedItemsPath, i.system.codename, (_a = updatedItem === null || updatedItem === void 0 ? void 0 : updatedItem.system.codename) !== null && _a !== void 0 ? _a : null)
                    ? createOptionallyAsync(() => i) // we found a cycle that doesn't need any update so we just ignore it
                    : applyUpdateOnItemOptionallyAsync(i, update, resolveElementCodename, newUpdatedItem, [
                        ...processedItemsPath,
                        i.system.codename,
                    ]);
            })), (linkedItems) => {
                return linkedItems.some((newItem, index) => newItem !== typedItemElement.linkedItems[index])
                    ? [elementCodename, Object.assign(Object.assign({}, typedItemElement), { linkedItems })]
                    : [elementCodename, typedItemElement];
            });
        }
        return createOptionallyAsync(() => [elementCodename, element]);
    }));
    return applyOnOptionallyAsync(updatedElements, (newElements) => {
        if ((newUpdatedItem === null || newUpdatedItem === void 0 ? void 0 : newUpdatedItem.system.codename) === item.system.codename) {
            newUpdatedItem.elements = Object.fromEntries(newElements);
            return newUpdatedItem;
        }
        return newElements.some(([codename, newEl]) => item.elements[codename] !== newEl)
            ? Object.assign(Object.assign({}, item), { elements: Object.fromEntries(newElements) }) : item;
    });
};
const closesCycleWithoutUpdate = (path, nextItem, updatedItem) => {
    const cycleStartIndex = path.indexOf(nextItem);
    return cycleStartIndex !== -1 && (!updatedItem || cycleStartIndex > path.indexOf(updatedItem));
};
const applyUpdateOnElement = (element, update, resolveCodenames) => {
    switch (update.type) {
        case ElementType.Text:
        case ElementType.Number:
        case ElementType.UrlSlug:
            return createOptionallyAsync(() => applySimpleElement(element, update));
        case ElementType.ModularContent:
            return applyLinkedItemsElement(element, update);
        case ElementType.RichText:
            return applyRichTextElement(element, update, resolveCodenames);
        case ElementType.MultipleChoice:
            return createOptionallyAsync(() => applyArrayElement(element, update, (o1, o2) => (o1 === null || o1 === void 0 ? void 0 : o1.codename) === (o2 === null || o2 === void 0 ? void 0 : o2.codename)));
        case ElementType.DateTime:
            return createOptionallyAsync(() => applyDateTimeElement(element, update));
        case ElementType.Asset:
            return createOptionallyAsync(() => applyArrayElement(element, update, (a1, a2) => (a1 === null || a1 === void 0 ? void 0 : a1.url) === (a2 === null || a2 === void 0 ? void 0 : a2.url)));
        case ElementType.Taxonomy:
            return createOptionallyAsync(() => applyArrayElement(element, update, (t1, t2) => (t1 === null || t1 === void 0 ? void 0 : t1.codename) === (t2 === null || t2 === void 0 ? void 0 : t2.codename)));
        case ElementType.Custom:
            return createOptionallyAsync(() => applyCustomElement(element, update));
        default:
            return createOptionallyAsync(() => element);
    }
};
const applyCustomElement = (element, update) => typeof element.value === 'string' && element.value !== update.data.value
    ? Object.assign(Object.assign({}, element), { value: update.data.value }) : element;
const applyDateTimeElement = (element, update) => element.value === update.data.value && element.displayTimeZone === update.data.displayTimeZone
    ? element
    : Object.assign(Object.assign({}, element), { value: update.data.value, displayTimeZone: update.data.displayTimeZone });
const applySimpleElement = (element, update) => (element.value === update.data.value ? element : Object.assign(Object.assign({}, element), { value: update.data.value }));
const applyArrayElement = (element, update, areSame) => element.value.length === update.data.value.length && element.value.every((el, i) => areSame(el, update.data.value[i]))
    ? element
    : Object.assign(Object.assign({}, element), { value: update.data.value });
const applyLinkedItemsElement = (element, update) => {
    if (areLinkedItemsSame(element.value, update.data.value)) {
        return createOptionallyAsync(() => element);
    }
    return applyOnOptionallyAsync(updateLinkedItems(update.data.value, element.linkedItems), (linkedItems) => (Object.assign(Object.assign({}, element), { value: update.data.value, linkedItems })));
};
const applyRichTextElement = (element, update, resolveCodenames) => {
    if (areRichTextElementsSame(element, update.data)) {
        return createOptionallyAsync(() => element);
    }
    const withItems = applyOnOptionallyAsync(updateLinkedItems(update.data.linkedItemCodenames, update.data.linkedItems
        .filter((i) => !element.linkedItems.find((u) => u.system.codename === i.system.codename))
        .map(applyCodenameResolver(resolveCodenames))
        .concat(element.linkedItems)), (linkedItems) => (Object.assign(Object.assign({}, element), { value: update.data.value, linkedItemCodenames: update.data.linkedItemCodenames, links: update.data.links, images: update.data.images, linkedItems })));
    return chainOptionallyAsync(withItems, (el) => applyOnOptionallyAsync(updateComponents(update.data.linkedItems, el.linkedItems, resolveCodenames), (linkedItems) => (Object.assign(Object.assign({}, el), { linkedItems }))));
};
const areItemsSame = (item1, item2) => item1.system.codename === item2.system.codename &&
    item1.system.language === item2.system.language &&
    Object.entries(item1.elements).every(([codename, el1]) => areElementsSame(el1, item2.elements[codename]));
const areElementsSame = (el1, el2) => {
    switch (el1.type) {
        case ElementType.Text:
        case ElementType.Number:
        case ElementType.UrlSlug:
            return el1.value === el2.value;
        case ElementType.MultipleChoice: {
            const typedElement1 = el1;
            const typedElement2 = el2;
            return (typedElement1.value.length === typedElement2.value.length &&
                typedElement1.value.every((option, i) => option.codename === el2.value[i].codename));
        }
        case ElementType.DateTime: {
            const typedElement1 = el1;
            const typedElement2 = el2;
            return (typedElement1.value === typedElement2.value && typedElement1.displayTimeZone === typedElement2.displayTimeZone);
        }
        case ElementType.RichText: {
            const typedElement1 = el1;
            const typedElement2 = el2;
            return areRichTextElementsSame(typedElement1, typedElement2);
        }
        case ElementType.Taxonomy: {
            const typedElement1 = el1;
            const typedElement2 = el2;
            return (typedElement1.value.length === typedElement2.value.length &&
                typedElement1.value.every((term, i) => term.codename === typedElement2.value[i].codename));
        }
        case ElementType.Asset: {
            const typedElement1 = el1;
            const typedElement2 = el2;
            return (typedElement1.value.length === typedElement2.value.length &&
                typedElement1.value.every((asset, i) => asset.url === typedElement2.value[i].url));
        }
        case ElementType.ModularContent: {
            const typedElement1 = el1;
            const typedElement2 = el2;
            return (typedElement1.value.length === typedElement2.value.length &&
                typedElement1.value.every((item, i) => item === typedElement2.value[i]));
        }
        case ElementType.Custom:
            return el1.value === el2.value;
        default:
            throw new Error();
    }
};
const areRichTextElementsSame = (el1, el2) => el1.value === el2.value &&
    el1.links.length === el2.links.length &&
    el1.links.every((link, i) => link.codename === el2.links[i].codename) &&
    el1.images.length === el2.images.length &&
    el1.images.every((image, i) => image.url === el2.images[i].url) &&
    el1.linkedItemCodenames.length === el2.linkedItemCodenames.length &&
    el1.linkedItemCodenames.every((codename, i) => codename === el2.linkedItemCodenames[i]) &&
    el1.linkedItems.length === el2.linkedItems.length &&
    el1.linkedItems.every((item, i) => areItemsSame(item, el2.linkedItems[i]));
const updateComponents = (newItems, oldItems, resolveCodenames) => mergeOptionalAsyncs(oldItems.map((item) => {
    const newItem = newItems.find((i) => i.system.codename === item.system.codename);
    return newItem
        ? applyUpdateOnItemOptionallyAsync(item, convertItemToUpdate(newItem), resolveCodenames)
        : createOptionallyAsync(() => item);
}));
const updateLinkedItems = (newValue, loadedItems) => {
    const itemsByCodename = new Map(loadedItems.map((i) => [i.system.codename, i]));
    const newLinkedItems = newValue.map((codename) => { var _a; return (_a = itemsByCodename.get(codename)) !== null && _a !== void 0 ? _a : codename; });
    const itemsToFetch = newLinkedItems.filter(isString);
    return applyOnOptionallyAsync(createOptionallyAsync((fetchItems) => (fetchItems && itemsToFetch.length ? fetchItems(itemsToFetch) : [])), (fetchedItemsArray) => {
        const fetchedItems = new Map(fetchedItemsArray.map((i) => [i.system.codename, i]));
        return newLinkedItems
            .map((codename) => { var _a; return (isString(codename) ? (_a = fetchedItems.get(codename)) !== null && _a !== void 0 ? _a : null : codename); })
            .filter(notNull);
    });
};
const areLinkedItemsSame = (items1, items2) => items1.length === items2.length && items1.every((codename, index) => codename === items2[index]);
const notNull = (value) => value !== null;
const isString = (value) => typeof value === 'string';
const convertItemToUpdate = (item) => ({
    variant: { codename: item.system.language },
    item: { codename: item.system.codename },
    elements: Object.entries(item.elements).map(([elCodename, el]) => {
        switch (el.type) {
            case ElementType.Number:
            case ElementType.UrlSlug:
            case ElementType.MultipleChoice:
            case ElementType.Custom:
            case ElementType.Asset:
            case ElementType.Text: {
                return {
                    element: { codename: elCodename },
                    type: el.type,
                    data: el,
                };
            }
            case ElementType.DateTime: {
                return {
                    element: { codename: elCodename },
                    type: el.type,
                    data: el,
                };
            }
            case ElementType.RichText: {
                return {
                    element: { codename: elCodename },
                    type: el.type,
                    data: el,
                };
            }
            case ElementType.Taxonomy: {
                return {
                    element: { codename: elCodename },
                    type: el.type,
                    data: el,
                };
            }
            case ElementType.ModularContent: {
                return {
                    element: { codename: elCodename },
                    type: el.type,
                    data: el,
                };
            }
            case ElementType.Unknown:
                throw new Error(`Cannot update element of type ${el.type}.`);
        }
    }),
});
const applyCodenameResolver = (resolver) => (item) => (Object.assign(Object.assign({}, item), { elements: Object.fromEntries(Object.entries(item.elements).map(([codename, element]) => {
        switch (element.type) {
            case ElementType.ModularContent:
            case ElementType.RichText:
                return [
                    resolver(codename),
                    Object.assign(Object.assign({}, element), { linkedItems: element.linkedItems.map(applyCodenameResolver(resolver)) }),
                ];
            default:
                return [resolver(codename), element];
        }
    })) }));
//# sourceMappingURL=liveReload.js.map