var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ButtonType, KSLButtonElement } from './KSLButtonElement';
import { IconName } from './KSLIconElement';
import { assert } from '../utils/assert';
import { KSLPopoverElement } from './KSLPopoverElement';
import { ElementPositionOffset, KSLPositionedElement } from './abstract/KSLPositionedElement';
import { KSLContainerElement } from './KSLContainerElement';
import { createTemplateForCustomElement } from '../utils/node';
import { MetadataAttribute, parseAddButtonDataAttributes } from '../utils/dataAttributes';
import { AddButtonAction, AddButtonElementType, AddButtonPermission, AddButtonPermissionCheckResult, } from '../lib/IFrameCommunicatorTypes';
import { Logger } from '../lib/Logger';
import { BaseZIndex } from './constants/zIndex';
const ContentIsPublishedTooltip = 'Content is published';
const DefaultTooltipMessage = 'Insert...';
const getCreateLinkedItemTooltip = (canUserCreateLinkedItem) => canUserCreateLinkedItem ? 'Create new item' : 'Your role cannot create items from the allowed types';
var PopoverButtonId;
(function (PopoverButtonId) {
    PopoverButtonId["CreateComponent"] = "create-component";
    PopoverButtonId["CreateLinkedItem"] = "create-linked-item";
    PopoverButtonId["InsertLinkedItem"] = "insert-linked-item";
})(PopoverButtonId || (PopoverButtonId = {}));
const getPopoverHtml = ({ elementType, isParentPublished, permissions }) => {
    const canUserCreateLinkedItem = permissions.get(AddButtonPermission.CreateNew) === AddButtonPermissionCheckResult.Ok;
    return `
    <style>
    .ksl-add-button__popover-button + .ksl-add-button__popover-button {
      margin-left: 4px;
    }
  </style>
  <ksl-button
    id="${PopoverButtonId.InsertLinkedItem}"
    class="ksl-add-button__popover-button"
    type="${ButtonType.Quinary}"
    tooltip-position="${ElementPositionOffset.Top}"
    tooltip-message="${isParentPublished ? ContentIsPublishedTooltip : 'Insert existing item'}"
    ${isParentPublished && 'disabled'}
  >
    <ksl-icon icon-name="${IconName.Puzzle}"/>
  </ksl-button>
  <ksl-button
    id="${PopoverButtonId.CreateLinkedItem}"
    class="ksl-add-button__popover-button"
    type="${ButtonType.Quinary}"
    tooltip-position="${ElementPositionOffset.Top}"
    tooltip-message="${isParentPublished ? ContentIsPublishedTooltip : getCreateLinkedItemTooltip(canUserCreateLinkedItem)}"
    ${(isParentPublished || !canUserCreateLinkedItem) && 'disabled'}
    ${elementType !== AddButtonElementType.LinkedItems && 'hidden'}
  >
    <ksl-icon icon-name="${IconName.PlusPuzzle}"/>
  </ksl-button>
  <ksl-button
    id="${PopoverButtonId.CreateComponent}"
    class="ksl-add-button__popover-button"
    type="${ButtonType.Quinary}"
    tooltip-position="${ElementPositionOffset.Top}"
    tooltip-message="${isParentPublished ? ContentIsPublishedTooltip : 'Insert new component'}"
    ${isParentPublished && 'disabled'}
    ${elementType !== AddButtonElementType.RichText && 'hidden'}
  >
    <ksl-icon icon-name="${IconName.CollapseScheme}"/>
  </ksl-button>
`;
};
const templateHTML = `
  <style>
    :host {
      display: inline-block;
      position: absolute;
      z-index: calc(var(--ksl-z-index, ${BaseZIndex}) + 20);
      pointer-events: all;
      touch-action: initial;
    }
    
    :host(:focus) {
      outline: none;
    }
  </style>
  <ksl-button
      type="${ButtonType.Primary}"
      tooltip-position="${ElementPositionOffset.Top}"
  >
    <ksl-icon icon-name="${IconName.Plus}"/>
  </ksl-button>
`;
export class KSLAddButtonElement extends KSLPositionedElement {
    constructor() {
        super();
        this.popoverRef = null;
        this.adjustPosition = () => {
            if (!this.targetRef || !this.offsetParent) {
                return;
            }
            if (!(this.offsetParent instanceof KSLContainerElement)) {
                console.warn('KSLAddButtonElement: should be located inside KSLContainerElement to be positioned properly.');
            }
            const offsetParentRect = this.offsetParent.getBoundingClientRect();
            const targetRect = this.targetRef.getBoundingClientRect();
            const thisRect = this.getBoundingClientRect();
            const verticalOffset = this.calculateTopOffset(thisRect, targetRect);
            const horizontalOffset = this.calculateLeftOffset(thisRect, targetRect);
            this.style.top = `${targetRect.top - offsetParentRect.top + verticalOffset}px`;
            this.style.left = `${targetRect.left - offsetParentRect.left + horizontalOffset}px`;
        };
        this.handleClick = (event) => __awaiter(this, void 0, void 0, function* () {
            if (this.popoverRef) {
                return;
            }
            assert(this.targetRef, 'Target node is not set for this add button.');
            event.preventDefault();
            event.stopPropagation();
            this.buttonRef.loading = true;
            const data = parseAddButtonDataAttributes(this.targetRef);
            try {
                const eventData = { data, targetNode: this.targetRef };
                const response = yield this.dispatchAsyncEvent('ksl:add-button:initial', eventData);
                const { permissions } = response;
                const isUserMissingPermissions = !permissions ||
                    permissions.get(AddButtonPermission.ViewParent) !== AddButtonPermissionCheckResult.Ok ||
                    permissions.get(AddButtonPermission.Edit) !== AddButtonPermissionCheckResult.Ok;
                const areComponentsForbidden = permissions.get(AddButtonPermission.CreateNew) === AddButtonPermissionCheckResult.RteWithForbiddenComponents;
                if (isUserMissingPermissions || areComponentsForbidden) {
                    this.buttonRef.loading = false;
                    this.buttonRef.disabled = true;
                    this.buttonRef.tooltipMessage = isUserMissingPermissions
                        ? 'You are not allowed to add content here'
                        : "Components and items can't be added here";
                }
                else {
                    this.buttonRef.loading = false;
                    this.buttonRef.disabled = false;
                    this.buttonRef.tooltipMessage = DefaultTooltipMessage;
                    this.showPopover(response);
                }
            }
            catch (reason) {
                Logger.error(reason);
                this.buttonRef.loading = false;
                this.buttonRef.disabled = true;
                if (reason && typeof reason.message === 'string') {
                    this.buttonRef.tooltipMessage = reason.message;
                }
                else {
                    this.buttonRef.tooltipMessage = 'Something went wrong';
                }
            }
        });
        this.handleClickOutside = (event) => {
            if (!this.popoverRef || !(event.target instanceof Element)) {
                return;
            }
            const clickedInside = this.isSameNode(event.target) || this.contains(event.target);
            if (!clickedInside) {
                this.hidePopover();
            }
        };
        this.showPopover = (response) => {
            assert(this.shadowRoot, 'Shadow root must be available in "open" mode.');
            if (this.popoverRef) {
                this.hidePopover();
            }
            this.buttonRef.tooltipPosition = ElementPositionOffset.Bottom;
            const popover = document.createElement(KSLPopoverElement.is);
            popover.innerHTML = getPopoverHtml(response);
            const popoverParent = this.shadowRoot;
            this.popoverRef = popoverParent.appendChild(popover);
            this.popoverRef.position = ElementPositionOffset.Top;
            this.popoverRef.attachTo(this);
            this.addPopoverEventListeners(response.elementType);
            this.popoverRef.visible = true;
            this.popoverRef.adjustPosition();
        };
        this.hidePopover = () => {
            this.buttonRef.tooltipPosition = ElementPositionOffset.Top;
            if (this.popoverRef) {
                this.removePopoverEventListeners();
                this.popoverRef.visible = false;
                this.popoverRef.remove();
                this.popoverRef = null;
            }
        };
        this.addPopoverEventListeners = (elementType) => {
            if (!this.popoverRef) {
                return;
            }
            const createComponentButtonRef = this.popoverRef.querySelector(`#${PopoverButtonId.CreateComponent}`);
            const createLinkedItemButtonRef = this.popoverRef.querySelector(`#${PopoverButtonId.CreateLinkedItem}`);
            const insertLinkedItemButtonRef = this.popoverRef.querySelector(`#${PopoverButtonId.InsertLinkedItem}`);
            if (createComponentButtonRef && elementType === AddButtonElementType.RichText) {
                createComponentButtonRef.addEventListener('click', this.handleCreateComponentClick);
            }
            if (createLinkedItemButtonRef && elementType === AddButtonElementType.LinkedItems) {
                createLinkedItemButtonRef.addEventListener('click', this.handleCreateLinkedItemClick);
            }
            if (insertLinkedItemButtonRef) {
                insertLinkedItemButtonRef.addEventListener('click', this.handleInsertLinkedItemClick);
            }
        };
        this.removePopoverEventListeners = () => {
            if (!this.popoverRef) {
                return;
            }
            const createComponentButtonRef = this.popoverRef.querySelector(`#${PopoverButtonId.CreateComponent}`);
            const createLinkedItemButtonRef = this.popoverRef.querySelector(`#${PopoverButtonId.CreateLinkedItem}`);
            const insertLinkedItemButtonRef = this.popoverRef.querySelector(`#${PopoverButtonId.InsertLinkedItem}`);
            if (createComponentButtonRef) {
                createComponentButtonRef.removeEventListener('click', this.handleCreateComponentClick);
            }
            if (createLinkedItemButtonRef) {
                createLinkedItemButtonRef.removeEventListener('click', this.handleCreateLinkedItemClick);
            }
            if (insertLinkedItemButtonRef) {
                insertLinkedItemButtonRef.removeEventListener('click', this.handleInsertLinkedItemClick);
            }
        };
        this.handleCreateComponentClick = (event) => {
            this.handleAddActionClick(event, AddButtonAction.CreateComponent);
        };
        this.handleCreateLinkedItemClick = (event) => {
            this.handleAddActionClick(event, AddButtonAction.CreateLinkedItem);
        };
        this.handleInsertLinkedItemClick = (event) => {
            this.handleAddActionClick(event, AddButtonAction.InsertLinkedItem);
        };
        this.handleAddActionClick = (event, action) => {
            assert(this.targetRef, 'Target node is not set for this add button.');
            event.preventDefault();
            event.stopPropagation();
            const data = parseAddButtonDataAttributes(this.targetRef);
            const customEvent = new CustomEvent('ksl:add-button:action', {
                detail: {
                    data: Object.assign(Object.assign({}, data), { action }),
                    targetNode: this.targetRef,
                },
            });
            this.hidePopover();
            this.dispatchEvent(customEvent);
        };
        assert(this.shadowRoot, 'Shadow root must be available in "open" mode.');
        this.buttonRef = this.shadowRoot.querySelector(KSLButtonElement.is);
    }
    static get is() {
        return 'ksl-add-button';
    }
    get position() {
        var _a, _b;
        return (_b = (_a = this.targetRef) === null || _a === void 0 ? void 0 : _a.getAttribute(MetadataAttribute.AddButtonRenderPosition)) !== null && _b !== void 0 ? _b : ElementPositionOffset.Bottom;
    }
    static initializeTemplate() {
        return createTemplateForCustomElement(templateHTML);
    }
    connectedCallback() {
        super.connectedCallback();
        window.addEventListener('click', this.handleClickOutside, { capture: true });
        this.buttonRef.addEventListener('click', this.handleClick);
        this.buttonRef.tooltipMessage = DefaultTooltipMessage;
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        window.removeEventListener('click', this.handleClickOutside, { capture: true });
        this.buttonRef.removeEventListener('click', this.handleClick);
        this.hidePopover();
    }
    calculateTopOffset(thisRect, targetRect) {
        const offset = super.calculateTopOffset(thisRect, targetRect);
        switch (this.position) {
            case ElementPositionOffset.TopStart:
            case ElementPositionOffset.Top:
            case ElementPositionOffset.TopEnd:
                return offset / 2;
            case ElementPositionOffset.BottomStart:
            case ElementPositionOffset.Bottom:
            case ElementPositionOffset.BottomEnd:
                return offset - thisRect.height / 2;
            default:
                return offset;
        }
    }
    calculateLeftOffset(thisRect, targetRect) {
        const offset = super.calculateLeftOffset(thisRect, targetRect);
        switch (this.position) {
            case ElementPositionOffset.LeftStart:
            case ElementPositionOffset.Left:
            case ElementPositionOffset.LeftEnd:
                return offset / 2;
            case ElementPositionOffset.RightStart:
            case ElementPositionOffset.Right:
            case ElementPositionOffset.RightEnd:
                return targetRect.width - thisRect.width / 2;
            default:
                return offset;
        }
    }
}
//# sourceMappingURL=KSLAddButtonElement.js.map