import { KSLCustomElement } from './KSLCustomElement';
export var ElementPositionOffset;
(function (ElementPositionOffset) {
    ElementPositionOffset["Bottom"] = "bottom";
    ElementPositionOffset["BottomEnd"] = "bottom-end";
    ElementPositionOffset["BottomStart"] = "bottom-start";
    ElementPositionOffset["Left"] = "left";
    ElementPositionOffset["LeftEnd"] = "left-end";
    ElementPositionOffset["LeftStart"] = "left-start";
    ElementPositionOffset["None"] = "";
    ElementPositionOffset["Right"] = "right";
    ElementPositionOffset["RightEnd"] = "right-end";
    ElementPositionOffset["RightStart"] = "right-start";
    ElementPositionOffset["Top"] = "top";
    ElementPositionOffset["TopEnd"] = "top-end";
    ElementPositionOffset["TopStart"] = "top-start";
})(ElementPositionOffset || (ElementPositionOffset = {}));
export class KSLPositionedElement extends KSLCustomElement {
    constructor() {
        super(...arguments);
        this.targetRef = null;
    }
    get position() {
        return ElementPositionOffset.None;
    }
    connectedCallback() {
        if (!this.hasAttribute('tabindex')) {
            this.setAttribute('tabindex', '-1');
        }
    }
    disconnectedCallback() {
        this.targetRef = null;
    }
    attachTo(element) {
        this.targetRef = element;
    }
    calculateTopOffset(thisRect, targetRect) {
        switch (this.position) {
            case ElementPositionOffset.TopStart:
            case ElementPositionOffset.Top:
            case ElementPositionOffset.TopEnd:
                return -thisRect.height;
            case ElementPositionOffset.BottomStart:
            case ElementPositionOffset.Bottom:
            case ElementPositionOffset.BottomEnd:
                return targetRect.height;
            case ElementPositionOffset.Left:
            case ElementPositionOffset.Right:
                return (targetRect.height - thisRect.height) / 2;
            case ElementPositionOffset.LeftEnd:
            case ElementPositionOffset.RightEnd:
                return targetRect.height - thisRect.height;
            case ElementPositionOffset.LeftStart:
            case ElementPositionOffset.RightStart:
            case ElementPositionOffset.None:
            default:
                return 0;
        }
    }
    calculateLeftOffset(thisRect, targetRect) {
        switch (this.position) {
            case ElementPositionOffset.Top:
            case ElementPositionOffset.Bottom:
                return (targetRect.width - thisRect.width) / 2;
            case ElementPositionOffset.TopEnd:
            case ElementPositionOffset.BottomEnd:
                return targetRect.width - thisRect.width;
            case ElementPositionOffset.LeftStart:
            case ElementPositionOffset.Left:
            case ElementPositionOffset.LeftEnd:
                return -thisRect.width;
            case ElementPositionOffset.RightStart:
            case ElementPositionOffset.Right:
            case ElementPositionOffset.RightEnd:
                return targetRect.width;
            case ElementPositionOffset.TopStart:
            case ElementPositionOffset.BottomStart:
            case ElementPositionOffset.None:
            default:
                return 0;
        }
    }
}
//# sourceMappingURL=KSLPositionedElement.js.map