import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/requires-port/index.js
var require_requires_port = __commonJS({
  "node_modules/requires-port/index.js"(exports, module) {
    "use strict";
    module.exports = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port)
        return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
  }
});

// node_modules/querystringify/index.js
var require_querystringify = __commonJS({
  "node_modules/querystringify/index.js"(exports) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var undef;
    function decode(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, " "));
      } catch (e) {
        return null;
      }
    }
    function encode3(input) {
      try {
        return encodeURIComponent(input);
      } catch (e) {
        return null;
      }
    }
    function querystring(query) {
      var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
      while (part = parser.exec(query)) {
        var key = decode(part[1]), value = decode(part[2]);
        if (key === null || value === null || key in result)
          continue;
        result[key] = value;
      }
      return result;
    }
    function querystringify(obj, prefix) {
      prefix = prefix || "";
      var pairs = [], value, key;
      if ("string" !== typeof prefix)
        prefix = "?";
      for (key in obj) {
        if (has.call(obj, key)) {
          value = obj[key];
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = "";
          }
          key = encode3(key);
          value = encode3(value);
          if (key === null || value === null)
            continue;
          pairs.push(key + "=" + value);
        }
      }
      return pairs.length ? prefix + pairs.join("&") : "";
    }
    exports.stringify = querystringify;
    exports.parse = querystring;
  }
});

// node_modules/url-parse/index.js
var require_url_parse = __commonJS({
  "node_modules/url-parse/index.js"(exports, module) {
    "use strict";
    var required = require_requires_port();
    var qs = require_querystringify();
    var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
    var CRHTLF = /[\n\r\t]/g;
    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
    var port = /:\d+$/;
    var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
    var windowsDriveLetter = /^[a-zA-Z]:/;
    function trimLeft(str) {
      return (str ? str : "").toString().replace(controlOrWhitespace, "");
    }
    var rules = [
      ["#", "hash"],
      // Extract from the back.
      ["?", "query"],
      // Extract from the back.
      function sanitize(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
      },
      ["/", "pathname"],
      // Extract from the back.
      ["@", "auth", 1],
      // Extract from the front.
      [NaN, "host", void 0, 1, 1],
      // Set left over value.
      [/:(\d*)$/, "port", void 0, 1],
      // RegExp the back.
      [NaN, "hostname", void 0, 1, 1]
      // Set left over.
    ];
    var ignore = { hash: 1, query: 1 };
    function lolcation(loc) {
      var globalVar;
      if (typeof window !== "undefined")
        globalVar = window;
      else if (typeof global !== "undefined")
        globalVar = global;
      else if (typeof self !== "undefined")
        globalVar = self;
      else
        globalVar = {};
      var location = globalVar.location || {};
      loc = loc || location;
      var finaldestination = {}, type = typeof loc, key;
      if ("blob:" === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ("string" === type) {
        finaldestination = new Url(loc, {});
        for (key in ignore)
          delete finaldestination[key];
      } else if ("object" === type) {
        for (key in loc) {
          if (key in ignore)
            continue;
          finaldestination[key] = loc[key];
        }
        if (finaldestination.slashes === void 0) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }
      return finaldestination;
    }
    function isSpecial(scheme) {
      return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
    }
    function extractProtocol(address, location) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      location = location || {};
      var match = protocolre.exec(address);
      var protocol = match[1] ? match[1].toLowerCase() : "";
      var forwardSlashes = !!match[2];
      var otherSlashes = !!match[3];
      var slashesCount = 0;
      var rest;
      if (forwardSlashes) {
        if (otherSlashes) {
          rest = match[2] + match[3] + match[4];
          slashesCount = match[2].length + match[3].length;
        } else {
          rest = match[2] + match[4];
          slashesCount = match[2].length;
        }
      } else {
        if (otherSlashes) {
          rest = match[3] + match[4];
          slashesCount = match[3].length;
        } else {
          rest = match[4];
        }
      }
      if (protocol === "file:") {
        if (slashesCount >= 2) {
          rest = rest.slice(2);
        }
      } else if (isSpecial(protocol)) {
        rest = match[4];
      } else if (protocol) {
        if (forwardSlashes) {
          rest = rest.slice(2);
        }
      } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
        rest = match[4];
      }
      return {
        protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount,
        rest
      };
    }
    function resolve(relative, base) {
      if (relative === "")
        return base;
      var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
      while (i--) {
        if (path[i] === ".") {
          path.splice(i, 1);
        } else if (path[i] === "..") {
          path.splice(i, 1);
          up++;
        } else if (up) {
          if (i === 0)
            unshift = true;
          path.splice(i, 1);
          up--;
        }
      }
      if (unshift)
        path.unshift("");
      if (last === "." || last === "..")
        path.push("");
      return path.join("/");
    }
    function Url(address, location, parser) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }
      var relative, extracted, parse2, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
      if ("object" !== type && "string" !== type) {
        parser = location;
        location = null;
      }
      if (parser && "function" !== typeof parser)
        parser = qs.parse;
      location = lolcation(location);
      extracted = extractProtocol(address || "", location);
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || "";
      address = extracted.rest;
      if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [/(.*)/, "pathname"];
      }
      for (; i < instructions.length; i++) {
        instruction = instructions[i];
        if (typeof instruction === "function") {
          address = instruction(address, url);
          continue;
        }
        parse2 = instruction[0];
        key = instruction[1];
        if (parse2 !== parse2) {
          url[key] = address;
        } else if ("string" === typeof parse2) {
          index = parse2 === "@" ? address.lastIndexOf(parse2) : address.indexOf(parse2);
          if (~index) {
            if ("number" === typeof instruction[2]) {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if (index = parse2.exec(address)) {
          url[key] = index[1];
          address = address.slice(0, index.index);
        }
        url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
        if (instruction[4])
          url[key] = url[key].toLowerCase();
      }
      if (parser)
        url.query = parser(url.query);
      if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
        url.pathname = resolve(url.pathname, location.pathname);
      }
      if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
        url.pathname = "/" + url.pathname;
      }
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = "";
      }
      url.username = url.password = "";
      if (url.auth) {
        index = url.auth.indexOf(":");
        if (~index) {
          url.username = url.auth.slice(0, index);
          url.username = encodeURIComponent(decodeURIComponent(url.username));
          url.password = url.auth.slice(index + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
      }
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
    }
    function set(part, value, fn) {
      var url = this;
      switch (part) {
        case "query":
          if ("string" === typeof value && value.length) {
            value = (fn || qs.parse)(value);
          }
          url[part] = value;
          break;
        case "port":
          url[part] = value;
          if (!required(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = "";
          } else if (value) {
            url.host = url.hostname + ":" + value;
          }
          break;
        case "hostname":
          url[part] = value;
          if (url.port)
            value += ":" + url.port;
          url.host = value;
          break;
        case "host":
          url[part] = value;
          if (port.test(value)) {
            value = value.split(":");
            url.port = value.pop();
            url.hostname = value.join(":");
          } else {
            url.hostname = value;
            url.port = "";
          }
          break;
        case "protocol":
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;
        case "pathname":
        case "hash":
          if (value) {
            var char = part === "pathname" ? "/" : "#";
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;
        case "username":
        case "password":
          url[part] = encodeURIComponent(value);
          break;
        case "auth":
          var index = value.indexOf(":");
          if (~index) {
            url.username = value.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = value.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(value));
          }
      }
      for (var i = 0; i < rules.length; i++) {
        var ins = rules[i];
        if (ins[4])
          url[ins[1]] = url[ins[1]].toLowerCase();
      }
      url.auth = url.password ? url.username + ":" + url.password : url.username;
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
      return url;
    }
    function toString3(stringify) {
      if (!stringify || "function" !== typeof stringify)
        stringify = qs.stringify;
      var query, url = this, host = url.host, protocol = url.protocol;
      if (protocol && protocol.charAt(protocol.length - 1) !== ":")
        protocol += ":";
      var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
      if (url.username) {
        result += url.username;
        if (url.password)
          result += ":" + url.password;
        result += "@";
      } else if (url.password) {
        result += ":" + url.password;
        result += "@";
      } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
        result += "@";
      }
      if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
        host += ":";
      }
      result += host + url.pathname;
      query = "object" === typeof url.query ? stringify(url.query) : url.query;
      if (query)
        result += "?" !== query.charAt(0) ? "?" + query : query;
      if (url.hash)
        result += url.hash;
      return result;
    }
    Url.prototype = { set, toString: toString3 };
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = qs;
    module.exports = Url;
  }
});

// node_modules/@kontent-ai/core-sdk/dist/es6/helpers/url.helper.js
var UrlHelper = class {
  /**
  * Adds query parameters to given url
  * @param url Url to which options will be added
  * @param options Query parameters to add
  */
  addOptionsToUrl(url, options) {
    if (options) {
      options.forEach((filter2) => {
        if (url.indexOf("?") > -1) {
          url += "&";
        } else {
          url += "?";
        }
        url += filter2.getParam();
      });
    }
    return url;
  }
};
var urlHelper = new UrlHelper();

// node_modules/@kontent-ai/core-sdk/dist/es6/helpers/header.helper.js
var HeaderHelper = class {
  constructor() {
    this.sdkVersionHeader = "X-KC-SDKID";
  }
  /**
  * Header identifying SDK type & version for internal purposes of Kontent.ai
  */
  getSdkIdHeader(info) {
    return {
      header: this.sdkVersionHeader,
      value: `${info.host};${info.name};${info.version}`
    };
  }
};
var headerHelper = new HeaderHelper();

// node_modules/@kontent-ai/core-sdk/dist/es6/helpers/headers-helper.js
function extractHeadersFromAxiosResponse(response) {
  const headers = [];
  for (const headerKey of Object.keys(response.headers)) {
    headers.push({
      header: headerKey,
      value: response.headers[headerKey]
    });
  }
  return headers;
}

// node_modules/@kontent-ai/core-sdk/dist/es6/helpers/retry-helper.js
var RetryHelper = class {
  constructor() {
    this.requestCancelledMessagePrefix = "Request cancelled";
    this.retryAfterHeaderName = "Retry-After";
    this.defaultRetryStatusCodes = [408, 429, 500, 502, 503, 504];
    this.defaultRetryStrategy = {
      addJitter: true,
      deltaBackoffMs: 1e3,
      maxAttempts: 5,
      canRetryError: (error) => this.canRetryErrorDefault(error)
    };
  }
  getRetryErrorResult(data) {
    var _a, _b, _c;
    if (data.error && data.error.message) {
      if (data.error.message.startsWith(this.requestCancelledMessagePrefix)) {
        return {
          canRetry: false,
          retryInMs: 0,
          maxRetries: 0
        };
      }
    }
    const canRetryError = data.retryStrategy.canRetryError ? data.retryStrategy.canRetryError(data.error) : this.defaultRetryStrategy.canRetryError(data.error);
    if (!canRetryError) {
      return {
        canRetry: false,
        retryInMs: 0,
        maxRetries: 0
      };
    }
    const maxRetries = (_a = data.retryStrategy.maxAttempts) !== null && _a !== void 0 ? _a : this.defaultRetryStrategy.maxAttempts;
    const maxRetriesReached = data.retryAttempt >= maxRetries;
    if (maxRetriesReached) {
      return {
        canRetry: false,
        retryInMs: 0,
        maxRetries
      };
    }
    const retryResult = this.tryGetRetryAfterInMsFromError(data.error);
    if (retryResult) {
      return {
        canRetry: true,
        retryInMs: retryResult,
        maxRetries
      };
    }
    const waitTimeMs = this.getNextWaitTimeMs((_b = data.retryStrategy.addJitter) !== null && _b !== void 0 ? _b : this.defaultRetryStrategy.addJitter, (_c = data.retryStrategy.deltaBackoffMs) !== null && _c !== void 0 ? _c : this.defaultRetryStrategy.deltaBackoffMs, data.retryAttempt);
    return {
      canRetry: true,
      retryInMs: waitTimeMs,
      maxRetries
    };
  }
  getRetryStrategyFromStrategyOptions(retryOptions) {
    if (!retryOptions) {
      return this.defaultRetryStrategy;
    }
    return retryOptions;
  }
  canRetryInTime(startTime, maxCumulativeWaitTimeMs) {
    const start = startTime.getTime();
    const now = (/* @__PURE__ */ new Date()).getTime();
    const differenceInMs = now - start;
    return {
      canRetry: differenceInMs < maxCumulativeWaitTimeMs,
      differenceInMs
    };
  }
  getNextWaitTimeMs(addJitter, deltaBackoffMs, retryAttempts) {
    if (!addJitter) {
      return deltaBackoffMs * Math.pow(2, retryAttempts);
    }
    const from = 0.8 * deltaBackoffMs;
    const to = 1.2 * deltaBackoffMs * Math.pow(2, retryAttempts);
    return this.randomNumberFromInterval(from, to);
  }
  canRetryErrorDefault(error) {
    const axiosError = this.tryGetAxiosError(error);
    if (!axiosError) {
      return false;
    }
    const statusCode = this.getStatusCodeFromError(error);
    const canRetryStatusCode = this.canRetryStatusCode(statusCode, this.defaultRetryStatusCodes);
    if (canRetryStatusCode) {
      return true;
    }
    return false;
  }
  tryGetRetryAfterInMsFromError(error) {
    const axiosError = this.tryGetAxiosError(error);
    if (!axiosError || !axiosError.response) {
      return void 0;
    }
    const headers = extractHeadersFromAxiosResponse(axiosError.response);
    const retryValueHeader = headers.find((m) => m.header.toLowerCase() === this.retryAfterHeaderName.toLowerCase());
    if (!retryValueHeader) {
      return void 0;
    }
    const retryInSeconds = +retryValueHeader.value;
    return retryInSeconds * 1e3;
  }
  canRetryStatusCode(statusCode, useRetryForResponseCodes) {
    return useRetryForResponseCodes.includes(statusCode);
  }
  getStatusCodeFromError(error) {
    const axiosError = this.tryGetAxiosError(error);
    if (!axiosError || !axiosError.response) {
      return 0;
    }
    return axiosError.response.status;
  }
  tryGetAxiosError(error) {
    if (!error) {
      return void 0;
    }
    if (error.isAxiosError) {
      return error;
    }
    const originalError = error.originalError;
    if (originalError && originalError.isAxiosError) {
      return originalError;
    }
    return void 0;
  }
  /**
   * min and max included
   */
  randomNumberFromInterval(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }
};
var retryHelper = new RetryHelper();

// node_modules/@kontent-ai/core-sdk/dist/es6/models/parameters.js
var Parameters;
(function(Parameters3) {
  class CustomParameter {
    /**
     * Custom parameter
     * @constructor
     * @param {string} name - Name of the parameter
     * @param {string} value - Value of the parameter
     */
    constructor(name, value) {
      this.name = name;
      this.value = value;
      if (!name) {
        throw Error(`Name of the custom parameter is not specified`);
      }
    }
    getParam() {
      return this.name;
    }
    getParamValue() {
      return this.value;
    }
  }
  Parameters3.CustomParameter = CustomParameter;
})(Parameters || (Parameters = {}));

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn) => (...args) => utils_default.asap(() => fn(...args));

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  let controller = new AbortController();
  let aborted;
  const onabort = function(cancel) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      const err = cancel instanceof Error ? cancel : this.reason;
      controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
    }
  };
  let timer = timeout && setTimeout(() => {
    onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
  }, timeout);
  const unsubscribe = () => {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach((signal2) => {
        signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
      });
      signals = null;
    }
  };
  signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
  const { signal } = controller;
  signal.unsubscribe = unsubscribe;
  return [signal, () => {
    timer && clearTimeout(timer);
    timer = null;
  }];
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize, encode3) {
  for await (const chunk of iterable) {
    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode3(String(chunk)), chunkSize);
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish, encode3) => {
  const iterator = readBytes(stream, chunkSize, encode3);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    return (await new Request(body).arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length = utils_default.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var fetch_default = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals_default([signal, cancelToken], timeout) : [];
  let finished, request;
  const onFinish = () => {
    !finished && setTimeout(() => {
      composedSignal && composedSignal.unsubscribe();
    });
    finished = true;
  };
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush, encodeText);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: withCredentials
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          isStreamResponse && onFinish();
        }, encodeText),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && onFinish();
    stopTimeout && stopTimeout();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    onFinish();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default.from(err, err && err.code, config, request);
  }
});

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.7.4";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/@kontent-ai/core-sdk/dist/es6/http/http.debugger.js
var HttpDebugger = class {
  /*
  Called when http request is started
  */
  debugStartHttpRequest() {
  }
  /*
  Called when http request is resolved
  */
  debugSuccessHttpRequest() {
  }
  /*
  Called when http request is being retried
  */
  debugRetryHttpRequest() {
  }
};
var httpDebugger = new HttpDebugger();

// node_modules/@kontent-ai/core-sdk/dist/es6/http/http.functions.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getWithRetryAsync(instance, call, functionsConfig, options) {
  var _a;
  return __awaiter(this, void 0, void 0, function* () {
    const retryStrategyOptions = (_a = options === null || options === void 0 ? void 0 : options.retryStrategy) !== null && _a !== void 0 ? _a : retryHelper.defaultRetryStrategy;
    return yield runWithRetryAsync({
      retryAttempt: 0,
      url: call.url,
      retryStrategy: retryStrategyOptions,
      functionsConfig,
      call: (retryAttempt) => __awaiter(this, void 0, void 0, function* () {
        var _b, _c;
        httpDebugger.debugStartHttpRequest();
        const axiosResponse = yield instance.get(call.url, {
          headers: getHeadersJson((_b = options === null || options === void 0 ? void 0 : options.headers) !== null && _b !== void 0 ? _b : [], false),
          responseType: options === null || options === void 0 ? void 0 : options.responseType,
          cancelToken: (_c = options === null || options === void 0 ? void 0 : options.cancelToken) === null || _c === void 0 ? void 0 : _c.token
        });
        const response = {
          data: axiosResponse.data,
          rawResponse: axiosResponse,
          headers: extractHeadersFromAxiosResponse(axiosResponse),
          status: axiosResponse.status,
          retryStrategy: {
            options: retryStrategyOptions,
            retryAttempts: retryAttempt
          }
        };
        httpDebugger.debugSuccessHttpRequest();
        return response;
      })
    });
  });
}
function postWithRetryAsync(instance, call, functionsConfig, options) {
  var _a;
  return __awaiter(this, void 0, void 0, function* () {
    const retryStrategyOptions = (_a = options === null || options === void 0 ? void 0 : options.retryStrategy) !== null && _a !== void 0 ? _a : retryHelper.defaultRetryStrategy;
    return yield runWithRetryAsync({
      retryAttempt: 0,
      url: call.url,
      retryStrategy: retryStrategyOptions,
      functionsConfig,
      call: (retryAttempt) => __awaiter(this, void 0, void 0, function* () {
        var _b, _c;
        httpDebugger.debugStartHttpRequest();
        const axiosResponse = yield instance.post(call.url, call.body, {
          headers: getHeadersJson((_b = options === null || options === void 0 ? void 0 : options.headers) !== null && _b !== void 0 ? _b : [], false),
          responseType: options === null || options === void 0 ? void 0 : options.responseType,
          // required for uploading large files
          // https://github.com/axios/axios/issues/1362
          maxContentLength: "Infinity",
          maxBodyLength: "Infinity",
          cancelToken: (_c = options === null || options === void 0 ? void 0 : options.cancelToken) === null || _c === void 0 ? void 0 : _c.token
        });
        const response = {
          data: axiosResponse.data,
          rawResponse: axiosResponse,
          headers: extractHeadersFromAxiosResponse(axiosResponse),
          status: axiosResponse.status,
          retryStrategy: {
            options: retryStrategyOptions,
            retryAttempts: retryAttempt
          }
        };
        httpDebugger.debugSuccessHttpRequest();
        return response;
      })
    });
  });
}
function putWithRetryAsync(instance, call, functionsConfig, options) {
  var _a;
  return __awaiter(this, void 0, void 0, function* () {
    const retryStrategyOptions = (_a = options === null || options === void 0 ? void 0 : options.retryStrategy) !== null && _a !== void 0 ? _a : retryHelper.defaultRetryStrategy;
    return yield runWithRetryAsync({
      retryAttempt: 0,
      url: call.url,
      retryStrategy: retryStrategyOptions,
      functionsConfig,
      call: (retryAttempt) => __awaiter(this, void 0, void 0, function* () {
        var _b, _c;
        httpDebugger.debugStartHttpRequest();
        const axiosResponse = yield instance.put(call.url, call.body, {
          headers: getHeadersJson((_b = options === null || options === void 0 ? void 0 : options.headers) !== null && _b !== void 0 ? _b : [], false),
          responseType: options === null || options === void 0 ? void 0 : options.responseType,
          // required for uploading large files
          // https://github.com/axios/axios/issues/1362
          maxContentLength: "Infinity",
          maxBodyLength: "Infinity",
          cancelToken: (_c = options === null || options === void 0 ? void 0 : options.cancelToken) === null || _c === void 0 ? void 0 : _c.token
        });
        const response = {
          data: axiosResponse.data,
          rawResponse: axiosResponse,
          headers: extractHeadersFromAxiosResponse(axiosResponse),
          status: axiosResponse.status,
          retryStrategy: {
            options: retryStrategyOptions,
            retryAttempts: retryAttempt
          }
        };
        httpDebugger.debugSuccessHttpRequest();
        return response;
      })
    });
  });
}
function patchWithRetryAsync(instance, call, functionsConfig, options) {
  var _a;
  return __awaiter(this, void 0, void 0, function* () {
    const retryStrategyOptions = (_a = options === null || options === void 0 ? void 0 : options.retryStrategy) !== null && _a !== void 0 ? _a : retryHelper.defaultRetryStrategy;
    return yield runWithRetryAsync({
      retryAttempt: 0,
      url: call.url,
      retryStrategy: retryStrategyOptions,
      functionsConfig,
      call: (retryAttempt) => __awaiter(this, void 0, void 0, function* () {
        var _b, _c;
        httpDebugger.debugStartHttpRequest();
        const axiosResponse = yield instance.patch(call.url, call.body, {
          headers: getHeadersJson((_b = options === null || options === void 0 ? void 0 : options.headers) !== null && _b !== void 0 ? _b : [], false),
          responseType: options === null || options === void 0 ? void 0 : options.responseType,
          // required for uploading large files
          // https://github.com/axios/axios/issues/1362
          maxContentLength: "Infinity",
          maxBodyLength: "Infinity",
          cancelToken: (_c = options === null || options === void 0 ? void 0 : options.cancelToken) === null || _c === void 0 ? void 0 : _c.token
        });
        const response = {
          data: axiosResponse.data,
          rawResponse: axiosResponse,
          headers: extractHeadersFromAxiosResponse(axiosResponse),
          status: axiosResponse.status,
          retryStrategy: {
            options: retryStrategyOptions,
            retryAttempts: retryAttempt
          }
        };
        httpDebugger.debugSuccessHttpRequest();
        return response;
      })
    });
  });
}
function deleteWithRetryAsync(instance, call, functionsConfig, options) {
  var _a;
  return __awaiter(this, void 0, void 0, function* () {
    const retryStrategyOptions = (_a = options === null || options === void 0 ? void 0 : options.retryStrategy) !== null && _a !== void 0 ? _a : retryHelper.defaultRetryStrategy;
    return yield runWithRetryAsync({
      retryAttempt: 0,
      url: call.url,
      retryStrategy: retryStrategyOptions,
      functionsConfig,
      call: (retryAttempt) => __awaiter(this, void 0, void 0, function* () {
        var _b, _c;
        httpDebugger.debugStartHttpRequest();
        const axiosResponse = yield instance.delete(call.url, {
          headers: getHeadersJson((_b = options === null || options === void 0 ? void 0 : options.headers) !== null && _b !== void 0 ? _b : [], false),
          responseType: options === null || options === void 0 ? void 0 : options.responseType,
          // required for uploading large files
          // https://github.com/axios/axios/issues/1362
          maxContentLength: "Infinity",
          maxBodyLength: "Infinity",
          cancelToken: (_c = options === null || options === void 0 ? void 0 : options.cancelToken) === null || _c === void 0 ? void 0 : _c.token
        });
        const response = {
          data: axiosResponse.data,
          rawResponse: axiosResponse,
          headers: extractHeadersFromAxiosResponse(axiosResponse),
          status: axiosResponse.status,
          retryStrategy: {
            options: retryStrategyOptions,
            retryAttempts: retryAttempt
          }
        };
        httpDebugger.debugSuccessHttpRequest();
        return response;
      })
    });
  });
}
function createCancelToken() {
  let canceler;
  const token = new axios_default.CancelToken((c) => {
    canceler = c;
  });
  return {
    cancel: (cancelMessage) => canceler(`${retryHelper.requestCancelledMessagePrefix}: ${cancelMessage !== null && cancelMessage !== void 0 ? cancelMessage : "User cancel"}`),
    token
  };
}
function runWithRetryAsync(data) {
  return __awaiter(this, void 0, void 0, function* () {
    try {
      return yield data.call(data.retryAttempt);
    } catch (error) {
      const retryResult = retryHelper.getRetryErrorResult({
        error,
        retryAttempt: data.retryAttempt,
        retryStrategy: data.retryStrategy
      });
      if (retryResult.canRetry) {
        httpDebugger.debugRetryHttpRequest();
        yield new Promise((resolve) => setTimeout(resolve, retryResult.retryInMs));
        if (data.functionsConfig.logErrorsToConsole) {
          console.warn(`Retry attempt '${data.retryAttempt + 1}' from a maximum of '${retryResult.maxRetries}' retries. Request url: '${data.url}'`);
        }
        return yield runWithRetryAsync({
          call: data.call,
          retryStrategy: data.retryStrategy,
          retryAttempt: data.retryAttempt + 1,
          url: data.url,
          functionsConfig: data.functionsConfig
        });
      }
      if (data.functionsConfig.logErrorsToConsole) {
        console.error(`Executing '${data.url}' failed. Request was retried '${data.retryAttempt}' times. `, error);
      }
      throw error;
    }
  });
}
function getHeadersJson(headers, addContentTypeHeader) {
  const headerJson = {};
  headers.forEach((header) => {
    headerJson[header.header] = header.value;
  });
  if (addContentTypeHeader) {
    const contentTypeHeader = headers.find((m) => m.header.toLowerCase() === "Content-Type".toLowerCase());
    if (!contentTypeHeader) {
      headerJson["Content-Type"] = "application/json";
    }
  }
  return headerJson;
}

// node_modules/@kontent-ai/core-sdk/dist/es6/http/http.service.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HttpService = class {
  constructor(opts) {
    this.opts = opts;
    this.axiosInstance = axios_default.create(opts === null || opts === void 0 ? void 0 : opts.axiosRequestConfig);
    this.functionsConfig = this.getFunctionsConfig();
  }
  getAsync(call, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield getWithRetryAsync(this.axiosInstance, call, this.functionsConfig, options);
    });
  }
  postAsync(call, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield postWithRetryAsync(this.axiosInstance, call, this.functionsConfig, options);
    });
  }
  putAsync(call, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield putWithRetryAsync(this.axiosInstance, call, this.functionsConfig, options);
    });
  }
  patchAsync(call, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield patchWithRetryAsync(this.axiosInstance, call, this.functionsConfig, options);
    });
  }
  deleteAsync(call, options) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield deleteWithRetryAsync(this.axiosInstance, call, this.functionsConfig, options);
    });
  }
  createCancelToken() {
    return createCancelToken();
  }
  getFunctionsConfig() {
    var _a, _b;
    return {
      logErrorsToConsole: (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.logErrorsToConsole) !== null && _b !== void 0 ? _b : true
    };
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/models/common/filters.js
var Filters;
(function(Filters2) {
  const valueSeparator = ",";
  const defaultValue = "";
  const getParamValueForSystemFilter = (param) => {
    if (!param) {
      return defaultValue;
    }
    if (Array.isArray(param)) {
      let value = "";
      for (let i = 0; i < param.length; i++) {
        value = value + param[i].toString();
        if (i !== param.length - 1) {
          value = value + valueSeparator;
        }
      }
      return value;
    }
    return param.toString();
  };
  class TypeFilter {
    constructor(type) {
      this.type = type;
    }
    getParam() {
      if (Array.isArray(this.type)) {
        return `system.type[in]=${getParamValueForSystemFilter(this.type)}`;
      }
      return `system.type=${getParamValueForSystemFilter(this.type)}`;
    }
  }
  Filters2.TypeFilter = TypeFilter;
  class CollectionFilter {
    constructor(collection) {
      this.collection = collection;
    }
    getParam() {
      if (Array.isArray(this.collection)) {
        return `system.collection[in]=${getParamValueForSystemFilter(this.collection)}`;
      }
      return `system.collection=${getParamValueForSystemFilter(this.collection)}`;
    }
  }
  Filters2.CollectionFilter = CollectionFilter;
  class EmptyFilter {
    constructor(element) {
      this.element = element;
    }
    getParam() {
      return `${this.element.trim()}[empty]`;
    }
  }
  Filters2.EmptyFilter = EmptyFilter;
  class NotEmptyFilter {
    constructor(element) {
      this.element = element;
    }
    getParam() {
      return `${this.element.trim()}[nempty]`;
    }
  }
  Filters2.NotEmptyFilter = NotEmptyFilter;
  class EqualsFilter {
    constructor(element, value) {
      this.element = element;
      this.value = value;
    }
    getParam() {
      return `${this.element.trim()}[eq]=${this.getParamValue()}`;
    }
    getParamValue() {
      if (!this.value) {
        return defaultValue;
      }
      return this.value;
    }
  }
  Filters2.EqualsFilter = EqualsFilter;
  class NotEqualsFilter {
    constructor(element, value) {
      this.element = element;
      this.value = value;
    }
    getParam() {
      return `${this.element.trim()}[neq]=${this.getParamValue()}`;
    }
    getParamValue() {
      if (!this.value) {
        return defaultValue;
      }
      return this.value;
    }
  }
  Filters2.NotEqualsFilter = NotEqualsFilter;
  class AllFilter {
    constructor(element, values) {
      this.element = element;
      this.values = values;
    }
    getParam() {
      return `${this.element.trim()}[all]=${this.getParamValue()}`;
    }
    getParamValue() {
      if (!this.values || !Array.isArray(this.values)) {
        return defaultValue;
      }
      return this.values.map((m) => m.trim()).join(",");
    }
  }
  Filters2.AllFilter = AllFilter;
  class AnyFilter {
    constructor(element, values) {
      this.element = element;
      this.values = values;
    }
    getParam() {
      return `${this.element.trim()}[any]=${this.getParamValue()}`;
    }
    getParamValue() {
      if (!this.values || !Array.isArray(this.values)) {
        return defaultValue;
      }
      return this.values.map((m) => m.trim()).join(",");
    }
  }
  Filters2.AnyFilter = AnyFilter;
  class ContainsFilter {
    constructor(element, values) {
      this.element = element;
      this.values = values;
    }
    getParam() {
      return `${this.element.trim()}[contains]=${this.getParamValue()}`;
    }
    getParamValue() {
      if (!this.values || !Array.isArray(this.values)) {
        return defaultValue;
      }
      return this.values.map((m) => m.trim()).join(",");
    }
  }
  Filters2.ContainsFilter = ContainsFilter;
  class GreaterThanFilter {
    constructor(element, value) {
      this.element = element;
      this.value = value;
    }
    getParam() {
      return `${this.element.trim()}[gt]=${this.getParamValue()}`;
    }
    getParamValue() {
      if (!this.value) {
        return defaultValue;
      }
      return this.value;
    }
  }
  Filters2.GreaterThanFilter = GreaterThanFilter;
  class GreaterThanOrEqualFilter {
    constructor(element, value) {
      this.element = element;
      this.value = value;
    }
    getParam() {
      return `${this.element.trim()}[gte]=${this.getParamValue()}`;
    }
    getParamValue() {
      if (!this.value) {
        return defaultValue;
      }
      return this.value;
    }
  }
  Filters2.GreaterThanOrEqualFilter = GreaterThanOrEqualFilter;
  class InFilter {
    constructor(element, values) {
      this.element = element;
      this.values = values;
    }
    getParam() {
      return `${this.element.trim()}[in]=${this.getParamValue()}`;
    }
    getParamValue() {
      if (!this.values || !Array.isArray(this.values)) {
        return defaultValue;
      }
      return this.values.map((m) => {
        return m.trim();
      }).join(",");
    }
  }
  Filters2.InFilter = InFilter;
  class NotInFilter {
    constructor(element, values) {
      this.element = element;
      this.values = values;
    }
    getParam() {
      return `${this.element.trim()}[nin]=${this.getParamValue()}`;
    }
    getParamValue() {
      if (!this.values || !Array.isArray(this.values)) {
        return defaultValue;
      }
      return this.values.map((m) => {
        return m.trim();
      }).join(",");
    }
  }
  Filters2.NotInFilter = NotInFilter;
  class LessThanFilter {
    constructor(element, value) {
      this.element = element;
      this.value = value;
    }
    getParam() {
      return `${this.element.trim()}[lt]=${this.getParamValue()}`;
    }
    getParamValue() {
      if (!this.value) {
        return defaultValue;
      }
      return this.value;
    }
  }
  Filters2.LessThanFilter = LessThanFilter;
  class LessThanOrEqualFilter {
    constructor(element, value) {
      this.element = element;
      this.value = value;
    }
    getParam() {
      return `${this.element.trim()}[lte]=${this.getParamValue()}`;
    }
    getParamValue() {
      if (!this.value) {
        return defaultValue;
      }
      return this.value;
    }
  }
  Filters2.LessThanOrEqualFilter = LessThanOrEqualFilter;
  class RangeFilter {
    constructor(element, lowerValue, higherValue) {
      this.element = element;
      this.lowerValue = lowerValue;
      this.higherValue = higherValue;
    }
    getParam() {
      return `${this.element.trim()}[range]=${this.getParamValue()}`;
    }
    getParamValue() {
      let lowerVal = defaultValue;
      let higherVal = defaultValue;
      if (this.lowerValue) {
        lowerVal = this.lowerValue.toString();
      }
      if (this.higherValue) {
        higherVal = this.higherValue.toString();
      }
      return `${lowerVal},${higherVal}`;
    }
  }
  Filters2.RangeFilter = RangeFilter;
})(Filters || (Filters = {}));

// node_modules/@kontent-ai/delivery-sdk/dist/es6/models/common/parameters.js
var Parameters2;
(function(Parameters3) {
  const defaultValue = "";
  class QueryParameter {
    /**
     * Parameter
     * @constructor
     * @param {string} name - Name of the parameter
     * @param {string} value - Value of the parameter
     */
    constructor(name, value) {
      this.name = name;
      this.value = value;
      if (!name) {
        throw Error(`Name of the parameter is not specified`);
      }
    }
    getParam() {
      return `${this.name}=${this.value}`;
    }
  }
  Parameters3.QueryParameter = QueryParameter;
  class ElementsParameter {
    /**
     * Sets elements (projection) so that only certain elements from a content item are returned
     * @constructor
     * @param {string[]} elementCodenames - Array of element codenames to include in response.
     */
    constructor(elementCodenames) {
      this.elementCodenames = elementCodenames;
    }
    getParam() {
      return `elements=${this.getParamValue()}`;
    }
    getParamValue() {
      if (!this.elementCodenames) {
        return defaultValue;
      }
      return this.elementCodenames.map((m) => {
        if (!m) {
          throw Error(`Codename of 'ElementsParameter' cannot be null or empty`);
        }
        return m.trim();
      }).join(",");
    }
  }
  Parameters3.ElementsParameter = ElementsParameter;
  class ExcludeElementsParameter {
    /**
     * Sets elements (projection) so that only certain elements are excluded from API response
     * @constructor
     * @param {string[]} elementCodenames - Array of element codenames to exclude from API response.
     */
    constructor(elementCodenames) {
      this.elementCodenames = elementCodenames;
    }
    getParam() {
      return `excludeElements=${this.getParamValue()}`;
    }
    getParamValue() {
      if (!this.elementCodenames) {
        return defaultValue;
      }
      return this.elementCodenames.map((m) => {
        if (!m) {
          throw Error(`Codename of 'ExcludeElementsParameter' cannot be null or empty`);
        }
        return m.trim();
      }).join(",");
    }
  }
  Parameters3.ExcludeElementsParameter = ExcludeElementsParameter;
  class LimitParameter {
    /**
     * Limits the number of items that are returned from response
     * @constructor
     * @param {number} limit - Number of elements that will be returned
     */
    constructor(limit) {
      this.limit = limit;
      if (limit <= 0) {
        throw Error(`'LimitParameter' must specify a positive integer`);
      }
    }
    getParam() {
      return `limit=${this.limit}`;
    }
  }
  Parameters3.LimitParameter = LimitParameter;
  class IncludeTotalCountParameter {
    /**
     * Adds 'includeTotalCount' query parameter to query
     * @constructor
     */
    constructor() {
    }
    getParam() {
      return `includeTotalCount=true`;
    }
  }
  Parameters3.IncludeTotalCountParameter = IncludeTotalCountParameter;
  class SkipParameter {
    /**
     * Configures response to skip certain number of items
     * @constructor
     * @param {number} skip - Number of content items that will be skipped
     */
    constructor(skip) {
      this.skip = skip;
      if (skip < 0) {
        throw Error(`'SkipParameter' must specify a positive integer number or zero."`);
      }
    }
    getParam() {
      return `skip=${this.skip}`;
    }
  }
  Parameters3.SkipParameter = SkipParameter;
  class OrderParameter {
    /**
     * Sorts the response based on given element.
     * @constructor
     * @param {string} element - Element that will be used for sorting (can be both elements.<elementname> or system.<elementname>)
     * @param {SortOrder} sortOrder - Order type (desc/asc). Defaults to 'asc' if SortOrder is null or invalid.
     */
    constructor(element, sortOrder) {
      this.element = element;
      this.sortOrder = sortOrder;
      if (!element) {
        throw Error(`Element specified in 'OrderParameter' is null or empty`);
      }
    }
    getParam() {
      return `order=${this.getParamValue()}`;
    }
    getParamValue() {
      return `${this.element.trim()}[${this.sortOrder}]`;
    }
  }
  Parameters3.OrderParameter = OrderParameter;
  class CustomParameter {
    constructor(param) {
      this.param = param;
    }
    getParam() {
      return this.param;
    }
  }
  Parameters3.CustomParameter = CustomParameter;
  class DepthParameter {
    /**
     * Configures the depth of the response. Content items might reference another 'linked items' using the Linked items element.
     * Recursively, these linked items can reference another linked items.
     * By default, only one level of linked content is returned.
     * @constructor
     * @param {number} depth - Depth fo the response
     */
    constructor(depth) {
      this.depth = depth;
      if (depth < 0) {
        throw Error(`'DepthParameter' must specify a positive integer or zero`);
      }
    }
    getParam() {
      return `depth=${this.depth}`;
    }
  }
  Parameters3.DepthParameter = DepthParameter;
  class LanguageParameter {
    /**
     * Specifies language version to fetch
     * @constructor
     * @param {string} languageCodename - Codename of the language
     */
    constructor(languageCodename) {
      this.languageCodename = languageCodename;
    }
    getParam() {
      return `language=${this.languageCodename}`;
    }
  }
  Parameters3.LanguageParameter = LanguageParameter;
})(Parameters2 || (Parameters2 = {}));

// node_modules/@kontent-ai/delivery-sdk/dist/es6/models/common/common-models.js
var DeliveryError = class {
  constructor(data) {
    this.message = data.message;
    this.requestId = data.requestId;
    this.errorCode = data.errorCode;
    this.specificCode = data.specificCode;
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/models/common/headers.js
var continuationTokenHeaderName = "X-Continuation";
var waitForLoadingNewContentHeader = "X-KC-Wait-For-Loading-New-Content";
var sdkVersionHeader = "X-KC-SDKID";
var staleContentHeaderName = "X-Stale-Content";

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/common/base-query.class.js
var BaseQuery = class {
  constructor(config, queryService) {
    this.config = config;
    this.queryService = queryService;
    this.parameters = [];
  }
  /**
   * Adds custom parameter to query
   * @param name Name of parameter
   * @param value Value of parameter
   */
  withCustomParameter(name, value) {
    this.parameters.push(new Parameters2.QueryParameter(name, value));
    return this;
  }
  /**
   * Adds parameter to query
   * @param name Name of parameter
   * @param value Value of parameter
   */
  withParameter(parameter) {
    this.parameters.push(parameter);
    return this;
  }
  /**
   * Adds parameters to query
   * @param parameters Array of parameters
   */
  withParameters(parameters) {
    this.parameters.push(...parameters);
    return this;
  }
  /**
   * Gets headers used by this query
   */
  getHeaders() {
    return this.queryService.getHeaders(this._queryConfig, []);
  }
  /**
   * Sets request headers
   */
  withHeaders(headers) {
    var _a;
    const queryHeaders = (_a = this._queryConfig.customHeaders) !== null && _a !== void 0 ? _a : [];
    queryHeaders.push(...headers);
    this._queryConfig.customHeaders = queryHeaders;
    return this;
  }
  /**
   * Sets request header
   */
  withHeader(header) {
    var _a;
    const queryHeaders = (_a = this._queryConfig.customHeaders) !== null && _a !== void 0 ? _a : [];
    queryHeaders.push(header);
    this._queryConfig.customHeaders = queryHeaders;
    return this;
  }
  /**
   * Sets custom URL of request (overrides default URL of the query)
   */
  withCustomUrl(url) {
    this.customUrl = url;
    return this;
  }
  /**
   * Gets all query parameter currently applied to query
   */
  getParameters() {
    return this.parameters;
  }
  /**
   * Used to configure query
   * @param queryConfig Query configuration
   */
  queryConfig(queryConfig) {
    this._queryConfig = queryConfig;
    return this;
  }
  resolveUrlInternal(action) {
    var _a;
    if (this.customUrl) {
      return this.customUrl;
    }
    return this.queryService.getUrl(action, (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {}, this.getParameters());
  }
  processDefaultLanguageParameter() {
    if (this.config.defaultLanguage) {
      const languageParameter = this.getParameters().find((m) => {
        var _a;
        return (_a = m.getParam()) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes("language=".toLowerCase());
      });
      if (!languageParameter) {
        this.parameters.push(new Parameters2.LanguageParameter(this.config.defaultLanguage));
      }
    }
  }
  processExcludeArchivedItemsParameter() {
    if (this.config.excludeArchivedItems) {
      this.parameters.push(new Filters.NotEqualsFilter("system.workflow_step", "archived"));
    }
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/element/element-query.class.js
var ElementQuery = class extends BaseQuery {
  constructor(config, queryService, typeCodename, elementCodename) {
    super(config, queryService);
    this.config = config;
    this.queryService = queryService;
    this.typeCodename = typeCodename;
    this.elementCodename = elementCodename;
    this._queryConfig = {};
    if (!typeCodename) {
      throw Error(`Codename of the type has to be provided`);
    }
    if (!elementCodename) {
      throw Error(`Codename of the element has to be provided`);
    }
  }
  toPromise() {
    var _a;
    return this.queryService.getElementAsync(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
  }
  getUrl() {
    return super.resolveUrlInternal(`/types/${this.typeCodename}/elements/${this.elementCodename}`);
  }
  map(json) {
    return this.queryService.mappingService.viewContentTypeElementResponse(json);
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/elements/element-type.js
var ElementType;
(function(ElementType2) {
  ElementType2["Text"] = "text";
  ElementType2["Number"] = "number";
  ElementType2["ModularContent"] = "modular_content";
  ElementType2["Asset"] = "asset";
  ElementType2["DateTime"] = "date_time";
  ElementType2["RichText"] = "rich_text";
  ElementType2["MultipleChoice"] = "multiple_choice";
  ElementType2["UrlSlug"] = "url_slug";
  ElementType2["Taxonomy"] = "taxonomy";
  ElementType2["Custom"] = "custom";
  ElementType2["Unknown"] = "unknown";
})(ElementType || (ElementType = {}));

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/common/base-listing-query.class.js
var BaseListingQuery = class extends BaseQuery {
  constructor(config, queryService) {
    super(config, queryService);
    this.config = config;
    this.queryService = queryService;
  }
  /**
   * Sets continuation token header
   */
  withContinuationToken(token) {
    var _a;
    let queryHeaders = (_a = this._queryConfig.customHeaders) !== null && _a !== void 0 ? _a : [];
    queryHeaders = queryHeaders.filter((m) => m.header !== continuationTokenHeaderName);
    this._queryConfig.customHeaders = queryHeaders;
    this.withHeaders([
      {
        header: continuationTokenHeaderName,
        value: token
      }
    ]);
    return this;
  }
  /**
   * Query to get all items. Uses paging data and may execute multiple HTTP requests depending on number of items
   */
  toAllPromise(queryAllConfig) {
    return this.queryService.getListAllResponse({
      page: 1,
      listQueryConfig: queryAllConfig,
      allResponseFactory: (items, responses) => {
        const response = this.allResponseFactory(items, responses);
        return {
          data: response,
          responses
        };
      },
      getResponse: (nextPageUrl, continuationToken) => {
        if (nextPageUrl) {
          this.withCustomUrl(nextPageUrl);
        }
        if (continuationToken) {
          this.withContinuationToken(continuationToken);
        }
        return this.toPromise();
      }
    });
  }
  linkItemsInRte(allContentItems) {
    for (const item of allContentItems) {
      for (const elementKey of Object.keys(item.elements)) {
        const element = item.elements[elementKey];
        if (element.type === ElementType.ModularContent) {
          const linkedItemElement = element;
          const orderedLinkedItems = [];
          for (const linkedItemCodename of linkedItemElement.value) {
            let linkedItem;
            const linkedItemInElement = linkedItemElement.linkedItems.find((m) => m.system.codename.toLowerCase() === linkedItemCodename.toLowerCase());
            if (linkedItemInElement) {
              linkedItem = linkedItemInElement;
            } else {
              linkedItem = allContentItems.find((m) => m.system.codename.toLowerCase() === linkedItemCodename.toLowerCase());
            }
            if (linkedItem) {
              orderedLinkedItems.push(linkedItem);
            }
          }
          linkedItemElement.linkedItems = orderedLinkedItems;
        }
        if (element.type === ElementType.RichText) {
          const orderedLinkedItems = [];
          const richTextElement = element;
          for (const linkedItemCodename of richTextElement.linkedItemCodenames) {
            let linkedItem;
            const linkedItemInElement = richTextElement.linkedItems.find((m) => m.system.codename.toLowerCase() === linkedItemCodename.toLowerCase());
            if (linkedItemInElement) {
              linkedItem = linkedItemInElement;
            } else {
              linkedItem = allContentItems.find((m) => m.system.codename.toLowerCase() === linkedItemCodename.toLowerCase());
            }
            if (linkedItem) {
              orderedLinkedItems.push(linkedItem);
            }
          }
          richTextElement.linkedItems = orderedLinkedItems;
        }
      }
    }
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/common/base-item-listing-query.class.js
var BaseItemListingQuery = class extends BaseListingQuery {
  constructor(config, queryService) {
    super(config, queryService);
    this.config = config;
    this.queryService = queryService;
  }
  /**
   * Empty filter condition
   * @param element Element with empty value
   */
  emptyFilter(element) {
    this.parameters.push(new Filters.EmptyFilter(element));
    return this;
  }
  /**
   * Not empty filter condition
   * @param element Element with non-empty value
   */
  notEmptyFilter(element) {
    this.parameters.push(new Filters.NotEmptyFilter(element));
    return this;
  }
  /**
   * Equals filter condition
   * @param element Element to filter. Example: 'elements.movie'
   * @param value Value to match. Example: 'Kingsman'
   */
  equalsFilter(element, value) {
    this.parameters.push(new Filters.EqualsFilter(element, value));
    return this;
  }
  /**
   * Not equals filter condition
   * @param element Element to filter. Example: 'elements.movie'
   * @param value Value to match. Example: 'Kingsman'
   */
  notEqualsFilter(element, value) {
    this.parameters.push(new Filters.NotEqualsFilter(element, value));
    return this;
  }
  /**
   * All filter
   * @param element Element to filter.
   * @param values Values
   */
  allFilter(element, values) {
    this.parameters.push(new Filters.AllFilter(element, values));
    return this;
  }
  /**
   * Any filter
   * @param element Element to filter.
   * @param values Values
   */
  anyFilter(element, values) {
    this.parameters.push(new Filters.AnyFilter(element, values));
    return this;
  }
  /**
   * Contains filter
   * @param element Element to filter.
   * @param values Values
   */
  containsFilter(element, values) {
    this.parameters.push(new Filters.ContainsFilter(element, values));
    return this;
  }
  /**
   * Greater then filter
   * @param element Element to filter.
   * @param value Value
   */
  greaterThanFilter(element, value) {
    this.parameters.push(new Filters.GreaterThanFilter(element, value));
    return this;
  }
  /**
   * Greater then or equals filter
   * @param element Element to filter.
   * @param value Value
   */
  greaterThanOrEqualFilter(element, value) {
    this.parameters.push(new Filters.GreaterThanOrEqualFilter(element, value));
    return this;
  }
  /**
   * In filter
   * @param element Element to filter.
   * @param values Values
   */
  inFilter(element, values) {
    this.parameters.push(new Filters.InFilter(element, values));
    return this;
  }
  /**
   * Not in filter
   * @param element Element to filter.
   * @param values Values
   */
  notInFilter(element, values) {
    this.parameters.push(new Filters.NotInFilter(element, values));
    return this;
  }
  /**
   * Less then filter
   * @param element Element to filter.
   * @param value Value
   */
  lessThanFilter(element, value) {
    this.parameters.push(new Filters.LessThanFilter(element, value));
    return this;
  }
  /**
   * @param element Element to filter.
   * @param value Value
   */
  lessThanOrEqualFilter(element, value) {
    this.parameters.push(new Filters.LessThanOrEqualFilter(element, value));
    return this;
  }
  /**
   * @param element Element to filter.
   * @param lowerValue Lower value of range (e.g. 2)
   * @param higherValue Higher value of range (e.g. 10)
   */
  rangeFilter(element, lowerValue, higherValue) {
    this.parameters.push(new Filters.RangeFilter(element, lowerValue, higherValue));
    return this;
  }
  /**
   * Limits the number of items returned by query
   * @param limit Number of items to load
   */
  limitParameter(limit) {
    this.parameters.push(new Parameters2.LimitParameter(limit));
    return this;
  }
  /**
   * Orders query based on given element and sort order
   * @param element Element by which to order
   * @param sortOrder Asc/Desc order type
   */
  orderParameter(element, sortOrder) {
    this.parameters.push(new Parameters2.OrderParameter(element, sortOrder));
    return this;
  }
  /**
   * Sets descending order on given element
   * @param element Element by which to order
   */
  orderByDescending(element) {
    this.parameters.push(new Parameters2.OrderParameter(element, "desc"));
    return this;
  }
  /**
   * Sets Ascending order on given element
   * @param element Element by which to order
   */
  orderByAscending(element) {
    this.parameters.push(new Parameters2.OrderParameter(element, "asc"));
    return this;
  }
  /**
   * Skips the selected number of items
   * @param skip Number of items to skip
   */
  skipParameter(skip) {
    this.parameters.push(new Parameters2.SkipParameter(skip));
    return this;
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/item/multiple-items-query.class.js
var MultipleItemsQuery = class extends BaseItemListingQuery {
  constructor(config, queryService) {
    super(config, queryService);
    this.config = config;
    this.queryService = queryService;
    this._queryConfig = {};
  }
  /**
   * Adds information about the total number of content items matching your query.
   * When set to true, the pagination object returned in the API response contains
   * an additional total_count property.
   */
  includeTotalCountParameter() {
    this.parameters.push(new Parameters2.IncludeTotalCountParameter());
    return this;
  }
  /**
   * Gets only item of given type
   * @param type Codename of type to get
   */
  type(type) {
    this.parameters.push(new Filters.TypeFilter(type));
    return this;
  }
  /**
   * Gets items of given types (logical or)
   * I.e. get items of either 'Actor' or 'Movie' type
   * @param types Types to get
   */
  types(types) {
    this.parameters.push(new Filters.TypeFilter(types));
    return this;
  }
  /**
   * Gets only item from given collection
   * @param collection Codename of collection to get
   */
  collection(collection) {
    this.parameters.push(new Filters.CollectionFilter(collection));
    return this;
  }
  /**
   * Gets items from given collections (logical or)
   * I.e. get items of either 'default' or 'christmas-campaign' collection
   * @param collections Collections to get
   */
  collections(collections) {
    this.parameters.push(new Filters.CollectionFilter(collections));
    return this;
  }
  /**
   * Indicates depth of query that affects loading of nested linked items.
   * @param depth Depth of the query (> 0)
   */
  depthParameter(depth) {
    this.parameters.push(new Parameters2.DepthParameter(depth));
    return this;
  }
  /**
   * Language codename
   * @param languageCodename Codename of the language
   */
  languageParameter(languageCodename) {
    this.parameters.push(new Parameters2.LanguageParameter(languageCodename));
    return this;
  }
  /**
   * Used to limit the number of elements returned by query.
   * @param elementCodenames Array of element codenames to fetch
   */
  elementsParameter(elementCodenames) {
    this.parameters.push(new Parameters2.ElementsParameter(elementCodenames));
    return this;
  }
  /**
   * Used to exclude elements returned by query.
   * @param elementCodenames Array of element codenames to exclude
   */
  excludeElementsParameter(elementCodenames) {
    this.parameters.push(new Parameters2.ExcludeElementsParameter(elementCodenames));
    return this;
  }
  toPromise() {
    var _a;
    return this.queryService.getMultipleItems(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
  }
  getUrl() {
    const action = "/items";
    this.processDefaultLanguageParameter();
    this.processExcludeArchivedItemsParameter();
    return super.resolveUrlInternal(action);
  }
  map(json) {
    return this.queryService.mappingService.listContentItemsResponse(json);
  }
  allResponseFactory(items, responses) {
    this.linkItems(items, responses);
    return {
      items,
      responses
    };
  }
  linkItems(items, responses) {
    const allContentItems = [];
    for (const response of responses) {
      allContentItems.push(...Object.values(response.data.linkedItems));
    }
    for (const item of items) {
      if (!allContentItems.find((m) => m.system.codename.toLowerCase() === item.system.codename.toLowerCase())) {
        allContentItems.push(item);
      }
    }
    this.linkItemsInRte(allContentItems);
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/item/single-item-query.class.js
var SingleItemQuery = class extends BaseQuery {
  constructor(config, queryService, codename) {
    super(config, queryService);
    this.config = config;
    this.queryService = queryService;
    this.codename = codename;
    this._queryConfig = {};
    if (!codename) {
      throw Error(`'codename' has to be configured for 'SingleItemQuery' query`);
    }
  }
  /**
   * Indicates depth of query that affects loading of nested linked items.
   * @param depth Depth of the query (> 0)
   */
  depthParameter(depth) {
    this.parameters.push(new Parameters2.DepthParameter(depth));
    return this;
  }
  /**
   * Used to configure query
   * @param queryConfig Query configuration
   */
  queryConfig(queryConfig) {
    this._queryConfig = queryConfig;
    return this;
  }
  /**
   * Language codename
   * @param languageCodename Codename of the language
   */
  languageParameter(languageCodename) {
    this.parameters.push(new Parameters2.LanguageParameter(languageCodename));
    return this;
  }
  /**
   * Used to limit the number of elements returned by query.
   * @param elementCodenames Array of element codenames to fetch
   */
  elementsParameter(elementCodenames) {
    this.parameters.push(new Parameters2.ElementsParameter(elementCodenames));
    return this;
  }
  /**
   * Used to exclude elements returned by query.
   * @param elementCodenames Array of element codenames to exclude
   */
  excludeElementsParameter(elementCodenames) {
    this.parameters.push(new Parameters2.ExcludeElementsParameter(elementCodenames));
    return this;
  }
  toPromise() {
    var _a;
    return this.queryService.getSingleItemAsync(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
  }
  getUrl() {
    const action = "/items/" + this.codename;
    this.processDefaultLanguageParameter();
    this.processExcludeArchivedItemsParameter();
    return super.resolveUrlInternal(action);
  }
  map(json) {
    return this.queryService.mappingService.viewContentItemResponse(json);
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/taxonomy/taxonomies-query.class.js
var TaxonomiesQuery = class extends BaseListingQuery {
  constructor(config, queryService) {
    super(config, queryService);
    this.config = config;
    this.queryService = queryService;
    this.taxonomiesEndpoint = "taxonomies";
    this._queryConfig = {};
  }
  /**
   * Limits the number of taxonomies returned by query
   * @param limit Number of taxonomies to load
   */
  limitParameter(limit) {
    this.parameters.push(new Parameters2.LimitParameter(limit));
    return this;
  }
  /**
   * Skips the selected number of taxonomies
   * @param skip Number of taxonomies to skip
   */
  skipParameter(skip) {
    this.parameters.push(new Parameters2.SkipParameter(skip));
    return this;
  }
  toPromise() {
    var _a;
    return this.queryService.getTaxonomies(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
  }
  getUrl() {
    const action = "/" + this.taxonomiesEndpoint;
    return super.resolveUrlInternal(action);
  }
  map(json) {
    return this.queryService.mappingService.listTaxonomiesResponse(json);
  }
  allResponseFactory(items, responses) {
    return {
      items,
      responses
    };
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/taxonomy/taxonomy-query.class.js
var TaxonomyQuery = class extends BaseQuery {
  constructor(config, queryService, taxonomyCodename) {
    super(config, queryService);
    this.config = config;
    this.queryService = queryService;
    this.taxonomyCodename = taxonomyCodename;
    this.taxonomiesEndpoint = "taxonomies";
    this._queryConfig = {};
    if (!taxonomyCodename) {
      throw Error(`Cannot create taxonomy query without codename of the taxonomy`);
    }
  }
  toPromise() {
    var _a;
    return this.queryService.getTaxonomy(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
  }
  getUrl() {
    const action = "/" + this.taxonomiesEndpoint + "/" + this.taxonomyCodename;
    return super.resolveUrlInternal(action);
  }
  map(json) {
    return this.queryService.mappingService.viewTaxonomyResponse(json);
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/type/multiple-type-query.class.js
var MultipleTypeQuery = class extends BaseListingQuery {
  constructor(config, queryService) {
    super(config, queryService);
    this.config = config;
    this.queryService = queryService;
    this._queryConfig = {};
  }
  /**
   * Used to limit the number of elements returned by query.
   * @param elementCodenames Array of element codenames to fetch
   */
  elementsParameter(elementCodenames) {
    this.parameters.push(new Parameters2.ElementsParameter(elementCodenames));
    return this;
  }
  /**
   * Used to exclude elements returned by query.
   * @param elementCodenames Array of element codenames to exclude
   */
  excludeElementsParameter(elementCodenames) {
    this.parameters.push(new Parameters2.ExcludeElementsParameter(elementCodenames));
    return this;
  }
  /**
   * Limits the number of taxonomies returned by query
   * @param limit Number of taxonomies to load
   */
  limitParameter(limit) {
    this.parameters.push(new Parameters2.LimitParameter(limit));
    return this;
  }
  /**
   * Skips the selected number of taxonomies
   * @param skip Number of taxonomies to skip
   */
  skipParameter(skip) {
    this.parameters.push(new Parameters2.SkipParameter(skip));
    return this;
  }
  toPromise() {
    var _a;
    return this.queryService.getMultipleTypes(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
  }
  getUrl() {
    const action = "/types";
    return super.resolveUrlInternal(action);
  }
  map(json) {
    return this.queryService.mappingService.listContentTypesResponse(json);
  }
  allResponseFactory(items, responses) {
    return {
      items,
      responses
    };
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/type/single-type-query.class.js
var SingleTypeQuery = class extends BaseQuery {
  constructor(config, queryService, typeCodename) {
    super(config, queryService);
    this.config = config;
    this.queryService = queryService;
    this.typeCodename = typeCodename;
    this._queryConfig = {};
    if (!typeCodename) {
      throw Error(`Cannot create type query without the codename of the type`);
    }
  }
  toPromise() {
    var _a;
    return this.queryService.getSingleType(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
  }
  getUrl() {
    const action = "/types/" + this.typeCodename;
    return super.resolveUrlInternal(action);
  }
  map(json) {
    return this.queryService.mappingService.viewContentTypeResponse(json);
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/items-feed/items-feed-query.class.js
var ItemsFeedQuery = class extends BaseItemListingQuery {
  constructor(config, queryService) {
    super(config, queryService);
    this.config = config;
    this.queryService = queryService;
    this._queryConfig = {};
  }
  /**
   * Gets only item of given type
   * @param type Codename of type to get
   */
  type(type) {
    this.parameters.push(new Filters.TypeFilter(type));
    return this;
  }
  /**
   * Gets items of given types (logical or)
   * I.e. get items of either 'Actor' or 'Movie' type
   * @param types Types to get
   */
  types(types) {
    this.parameters.push(new Filters.TypeFilter(types));
    return this;
  }
  /**
   * Gets only item from given collection
   * @param collection Codename of collection to get
   */
  collection(collection) {
    this.parameters.push(new Filters.CollectionFilter(collection));
    return this;
  }
  /**
   * Gets items from given collections (logical or)
   * I.e. get items of either 'default' or 'christmas-campaign' collection
   * @param collections Collections to get
   */
  collections(collections) {
    this.parameters.push(new Filters.CollectionFilter(collections));
    return this;
  }
  /**
   * Language codename
   * @param languageCodename Codename of the language
   */
  languageParameter(languageCodename) {
    this.parameters.push(new Parameters2.LanguageParameter(languageCodename));
    return this;
  }
  /**
   * Used to limit the number of elements returned by query.
   * @param elementCodenames Array of element codenames to fetch
   */
  elementsParameter(elementCodenames) {
    this.parameters.push(new Parameters2.ElementsParameter(elementCodenames));
    return this;
  }
  /**
   * Used to exclude elements returned by query.
   * @param elementCodenames Array of element codenames to exclude
   */
  excludeElementsParameter(elementCodenames) {
    this.parameters.push(new Parameters2.ExcludeElementsParameter(elementCodenames));
    return this;
  }
  toPromise() {
    var _a;
    return this.queryService.getItemsFeed(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
  }
  getUrl() {
    const action = "/items-feed";
    this.processDefaultLanguageParameter();
    this.processExcludeArchivedItemsParameter();
    return super.resolveUrlInternal(action);
  }
  /**
   * Used to configure query
   * @param queryConfig Query configuration
   */
  queryConfig(queryConfig) {
    this._queryConfig = queryConfig;
    return this;
  }
  map(json) {
    return this.queryService.mappingService.itemsFeedResponse(json);
  }
  allResponseFactory(items, responses) {
    if (this.canLinkItems()) {
      this.linkFeedItems(items, responses);
    }
    return {
      items,
      responses
    };
  }
  linkFeedItems(items, responses) {
    const allAvailableContentItems = [];
    for (const response of responses) {
      allAvailableContentItems.push(...Object.values(response.data.linkedItems));
    }
    for (const item of items) {
      if (!allAvailableContentItems.find((m) => m.system.codename.toLowerCase() === item.system.codename.toLowerCase())) {
        allAvailableContentItems.push(item);
      }
    }
    this.linkItemsInRte(allAvailableContentItems);
  }
  canLinkItems() {
    if (this.config.linkedItemsReferenceHandler === "ignore") {
      return false;
    }
    if (this._queryConfig.disableItemLinking === true) {
      return false;
    }
    return true;
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/language/languages-query.class.js
var LanguagesQuery = class extends BaseListingQuery {
  constructor(config, queryService) {
    super(config, queryService);
    this.config = config;
    this.queryService = queryService;
    this.endpoint = "languages";
    this._queryConfig = {};
  }
  /**
   * Limits the number of taxonomies returned by query
   * @param limit Number of taxonomies to load
   */
  limitParameter(limit) {
    this.parameters.push(new Parameters2.LimitParameter(limit));
    return this;
  }
  /**
   * Skips the selected number of taxonomies
   * @param skip Number of taxonomies to skip
   */
  skipParameter(skip) {
    this.parameters.push(new Parameters2.SkipParameter(skip));
    return this;
  }
  toPromise() {
    var _a;
    return this.queryService.getLanguages(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
  }
  getUrl() {
    const action = "/" + this.endpoint;
    return super.resolveUrlInternal(action);
  }
  /**
   * Used to configure query
   * @param queryConfig Query configuration
   */
  queryConfig(queryConfig) {
    this._queryConfig = queryConfig;
    return this;
  }
  map(json) {
    return this.queryService.mappingService.listLanguagesResponse(json);
  }
  allResponseFactory(items, responses) {
    return {
      items,
      responses
    };
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/sync/initialize-sync-query.class.js
var InitializeSyncQuery = class extends BaseQuery {
  constructor(config, queryService) {
    super(config, queryService);
    this.config = config;
    this.queryService = queryService;
    this.endpoint = "sync/init";
    this._queryConfig = {};
  }
  /**
   * Gets only item of given type
   * @param type Codename of type to get
   */
  type(type) {
    this.parameters.push(new Filters.TypeFilter(type));
    return this;
  }
  /**
   * Gets only item from given collection
   * @param collection Codename of collection to get
   */
  collection(collection) {
    this.parameters.push(new Filters.CollectionFilter(collection));
    return this;
  }
  /**
   * Language codename
   * @param languageCodename Codename of the language
   */
  languageParameter(languageCodename) {
    this.parameters.push(new Parameters2.LanguageParameter(languageCodename));
    return this;
  }
  toPromise() {
    var _a;
    return this.queryService.initializeSync(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
  }
  getUrl() {
    const action = "/" + this.endpoint;
    return super.resolveUrlInternal(action);
  }
  /**
   * Used to configure query
   * @param queryConfig Query configuration
   */
  queryConfig(queryConfig) {
    this._queryConfig = queryConfig;
    return this;
  }
  map(json) {
    return this.queryService.mappingService.initializeContentSync(json);
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/query/sync/sync-changes-query.class.js
var SyncChangesQuery = class extends BaseListingQuery {
  constructor(config, queryService) {
    super(config, queryService);
    this.config = config;
    this.queryService = queryService;
    this._queryConfig = {};
    this.action = "/sync";
  }
  toPromise() {
    var _a;
    return this.queryService.syncChanges(this.getUrl(), (_a = this._queryConfig) !== null && _a !== void 0 ? _a : {});
  }
  getUrl() {
    return super.resolveUrlInternal(this.action);
  }
  /**
   * Used to configure query
   * @param queryConfig Query configuration
   */
  queryConfig(queryConfig) {
    this._queryConfig = queryConfig;
    return this;
  }
  map(json) {
    return this.queryService.mappingService.syncChanges(json);
  }
  allResponseFactory(items, responses) {
    return {
      items,
      responses
    };
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/sdk-info.generated.js
var sdkInfo = {
  host: "npmjs.com",
  version: "14.11.0",
  name: "@kontent-ai/delivery-sdk"
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/services/base-delivery-query.service.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BaseDeliveryQueryService = class {
  constructor(config, httpService, sdkInfo2, mappingService) {
    this.config = config;
    this.httpService = httpService;
    this.sdkInfo = sdkInfo2;
    this.mappingService = mappingService;
    this.defaultBaseDeliveryApiUrl = "https://deliver.kontent.ai";
    this.defaultPreviewDeliveryApiUrl = "https://preview-deliver.kontent.ai";
  }
  /**
   * Gets url based on the action, query configuration and options (parameters)
   * @param action Action (= url part) that will be hit
   * @param queryConfig Query configuration
   * @param options Query options
   */
  getUrl(action, queryConfig, options) {
    if (!this.config.proxy || !this.config.proxy.advancedProxyUrlResolver) {
      return urlHelper.addOptionsToUrl(this.getBaseUrl(queryConfig) + action, options);
    }
    return this.config.proxy.advancedProxyUrlResolver({
      queryParameters: options ? options : [],
      queryString: urlHelper.addOptionsToUrl("", options),
      action,
      domain: this.getDomain(queryConfig),
      queryConfig,
      environmentId: this.config.environmentId
    });
  }
  /**
   * Gets proper set of headers for given request.
   * @param queryConfig Query configuration
   * @param additionalHeaders Custom headers
   */
  getHeaders(queryConfig, additionalHeaders) {
    const headers = [];
    if (additionalHeaders) {
      headers.push(...additionalHeaders);
    }
    headers.push(this.getSdkIdHeader());
    if (this.config.globalHeaders) {
      headers.push(...this.config.globalHeaders(queryConfig));
    }
    headers.push(...this.getQueryHeaders(queryConfig));
    if (this.isPreviewModeEnabled(queryConfig) && this.isSecuredModeEnabled(queryConfig)) {
      throw Error(`Preview & secured modes cannot be used at the same time.`);
    }
    if (this.isPreviewModeEnabled(queryConfig) && this.config.previewApiKey) {
      headers.push(this.getAuthorizationHeader(this.config.previewApiKey));
    }
    if (this.isSecuredModeEnabled(queryConfig) && this.config.secureApiKey) {
      headers.push(this.getAuthorizationHeader(this.config.secureApiKey));
    }
    if (this.shouldAddWaitForLoadingNewContentHeader(queryConfig)) {
      headers.push({
        header: waitForLoadingNewContentHeader,
        value: "true"
      });
    }
    return headers;
  }
  /**
   * Http POST response
   * @param url Url of request
   * @param queryConfig Query config configuration
   */
  postResponseAsync(url, body, queryConfig, serviceConfig) {
    return __awaiter3(this, void 0, void 0, function* () {
      if (!queryConfig) {
        queryConfig = {};
      }
      if (!serviceConfig) {
        serviceConfig = {};
      }
      try {
        return yield this.httpService.postAsync({
          url,
          body
        }, {
          cancelToken: queryConfig === null || queryConfig === void 0 ? void 0 : queryConfig.cancelToken,
          responseType: "json",
          retryStrategy: this.config.retryStrategy,
          headers: this.getHeaders(queryConfig, serviceConfig.headers ? serviceConfig.headers : [])
        });
      } catch (error) {
        throw this.mapDeliveryError(error);
      }
    });
  }
  /**
   * Http GET response
   * @param url Url of request
   * @param queryConfig Query config configuration
   */
  getResponseAsync(url, queryConfig, serviceConfig) {
    return __awaiter3(this, void 0, void 0, function* () {
      if (!queryConfig) {
        queryConfig = {};
      }
      if (!serviceConfig) {
        serviceConfig = {};
      }
      try {
        return yield this.httpService.getAsync({
          url
        }, {
          cancelToken: queryConfig === null || queryConfig === void 0 ? void 0 : queryConfig.cancelToken,
          responseType: "json",
          retryStrategy: this.config.retryStrategy,
          headers: this.getHeaders(queryConfig, serviceConfig.headers ? serviceConfig.headers : [])
        });
      } catch (error) {
        throw this.mapDeliveryError(error);
      }
    });
  }
  /**
   * Gets base URL of the request including the environment Id
   * @param queryConfig Query configuration
   */
  getBaseUrl(queryConfig) {
    return this.getDomain(queryConfig) + "/" + this.config.environmentId;
  }
  mapNetworkResponse(data, response) {
    return {
      data,
      response,
      hasStaleContent: this.getHasStaleContent(response.headers),
      xContinuationToken: this.getContinuationToken(response.headers)
    };
  }
  /**
   * Indicates if current query should use preview mode
   * @param queryConfig Query configuration
   */
  isPreviewModeEnabled(queryConfig) {
    if (queryConfig.usePreviewMode !== void 0) {
      return queryConfig.usePreviewMode;
    }
    if (!this.config.defaultQueryConfig) {
      return false;
    }
    if (this.config.defaultQueryConfig.usePreviewMode === true) {
      return true;
    }
    return false;
  }
  getQueryHeaders(queryConfig) {
    var _a;
    if (queryConfig.customHeaders) {
      return queryConfig.customHeaders;
    }
    if ((_a = this.config.defaultQueryConfig) === null || _a === void 0 ? void 0 : _a.customHeaders) {
      return this.config.defaultQueryConfig.customHeaders;
    }
    return [];
  }
  shouldAddWaitForLoadingNewContentHeader(queryConfig) {
    if (queryConfig.waitForLoadingNewContent !== void 0) {
      return queryConfig.waitForLoadingNewContent;
    }
    if (!this.config.defaultQueryConfig) {
      return false;
    }
    if (this.config.defaultQueryConfig.waitForLoadingNewContent === true) {
      return true;
    }
    return false;
  }
  /**
   * Indicates if current query should use secured mode
   * @param queryConfig Query configuration
   */
  isSecuredModeEnabled(queryConfig) {
    if (queryConfig.useSecuredMode !== void 0) {
      return queryConfig.useSecuredMode;
    }
    if (!this.config.defaultQueryConfig) {
      return false;
    }
    if (this.config.defaultQueryConfig.useSecuredMode === true) {
      return true;
    }
    return false;
  }
  /**
   * Gets preview or standard URL based on client and query configuration
   * @param queryConfig Query configuration
   */
  getDomain(queryConfig) {
    if (this.isPreviewModeEnabled(queryConfig)) {
      if (!this.config.previewApiKey) {
        throw Error(`Preview API key is not configured.`);
      }
      if (this.config.proxy && this.config.proxy.basePreviewUrl) {
        return this.config.proxy.basePreviewUrl;
      }
      return this.defaultPreviewDeliveryApiUrl;
    }
    if (this.config.proxy && this.config.proxy.baseUrl) {
      return this.config.proxy.baseUrl;
    }
    return this.defaultBaseDeliveryApiUrl;
  }
  /**
   * Gets authorization header. This is used for 'preview' functionality
   */
  getAuthorizationHeader(key) {
    if (!key) {
      throw Error(`Cannot get authorization header because key is invalid`);
    }
    return {
      header: "authorization",
      value: `bearer ${key}`
    };
  }
  /**
   * Header identifying SDK type & version for internal purposes of Kontent.ai
   */
  getSdkIdHeader() {
    return {
      header: sdkVersionHeader,
      value: `${this.sdkInfo.host};${this.sdkInfo.name};${this.sdkInfo.version}`
    };
  }
  mapDeliveryError(error) {
    var _a;
    let axiosError;
    if (error.error) {
      axiosError = error.error;
    } else {
      axiosError = error;
    }
    if (!axiosError || !axiosError.isAxiosError) {
      return error;
    }
    const deliveryErrorData = (_a = axiosError.response) === null || _a === void 0 ? void 0 : _a.data;
    if (!deliveryErrorData || !deliveryErrorData.error_code) {
      return error;
    }
    return new DeliveryError({
      errorCode: deliveryErrorData.error_code,
      message: deliveryErrorData.message,
      specificCode: deliveryErrorData.specific_code,
      requestId: deliveryErrorData.request_id
    });
  }
  getHasStaleContent(headers) {
    const hasStaleContentHeader = headers.find((m) => m.header.toLowerCase() === staleContentHeaderName.toLowerCase());
    if (hasStaleContentHeader) {
      if (hasStaleContentHeader.value.toString() === "1") {
        return true;
      }
    }
    return false;
  }
  getContinuationToken(headers) {
    const header = headers.find((m) => m.header.toLowerCase() === continuationTokenHeaderName.toLowerCase());
    return header ? header.value : void 0;
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/services/delivery-query.service.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var QueryService = class extends BaseDeliveryQueryService {
  constructor(config, httpService, sdkInfo2, mappingService) {
    super(config, httpService, sdkInfo2, mappingService);
  }
  /**
   * Gets single item from given url
   * @param url Url used to get single item
   * @param queryConfig Query configuration
   */
  getSingleItemAsync(url, queryConfig) {
    return __awaiter4(this, void 0, void 0, function* () {
      const response = yield this.getResponseAsync(url, queryConfig);
      return this.mapNetworkResponse(this.mappingService.viewContentItemResponse(response.data), response);
    });
  }
  /**
   * Gets single feed response. Might not contain all items in your environment.
   * @param url Url
   * @param queryConfig Query configuration
   */
  getItemsFeed(url, queryConfig) {
    return __awaiter4(this, void 0, void 0, function* () {
      const response = yield this.getResponseAsync(url, queryConfig);
      return this.mapNetworkResponse(this.mappingService.itemsFeedResponse(response.data), response);
    });
  }
  /**
   * Gets multiple items from given url
   * @param url Url used to get multiple items
   * @param queryConfig Query configuration
   */
  getMultipleItems(url, queryConfig) {
    return __awaiter4(this, void 0, void 0, function* () {
      const response = yield this.getResponseAsync(url, queryConfig);
      return this.mapNetworkResponse(this.mappingService.listContentItemsResponse(response.data), response);
    });
  }
  /**
   * Gets single content type from given url
   * @param url Url used to get single type
   * @param queryConfig Query configuration
   */
  getSingleType(url, queryConfig) {
    return __awaiter4(this, void 0, void 0, function* () {
      const response = yield this.getResponseAsync(url, queryConfig);
      return this.mapNetworkResponse(this.mappingService.viewContentTypeResponse(response.data), response);
    });
  }
  /**
   * Gets multiple content types from given url
   * @param url Url used to get multiple types
   * @param queryConfig Query configuration
   */
  getMultipleTypes(url, queryConfig) {
    return __awaiter4(this, void 0, void 0, function* () {
      const response = yield this.getResponseAsync(url, queryConfig);
      return this.mapNetworkResponse(this.mappingService.listContentTypesResponse(response.data), response);
    });
  }
  /**
   * Initializes synchronization of changes in content items based on the specified parameters. After the initialization,
   * you'll get an X-Continuation token in the response.
   * Use the token to synchronize changes in the content items matching the initialization criteria.
   * @param url Url
   * @param queryConfig Query configuration
   */
  initializeSync(url, queryConfig) {
    return __awaiter4(this, void 0, void 0, function* () {
      const response = yield this.postResponseAsync(url, {}, queryConfig);
      return this.mapNetworkResponse(this.mappingService.initializeContentSync(response.data), response);
    });
  }
  /**
   * Retrieve a list of delta updates to recently changed content items in the specified environment.
   * The types of items you get is determined by the X-Continuation token you use.
   * @param url Url used to get multiple types
   * @param queryConfig Query configuration
   */
  syncChanges(url, queryConfig) {
    return __awaiter4(this, void 0, void 0, function* () {
      const response = yield this.getResponseAsync(url, queryConfig);
      return this.mapNetworkResponse(this.mappingService.syncChanges(response.data), response);
    });
  }
  /**
   * Gets languages
   * @param url Url
   * @param queryConfig Query configuration
   */
  getLanguages(url, queryConfig) {
    return __awaiter4(this, void 0, void 0, function* () {
      const response = yield this.getResponseAsync(url, queryConfig);
      return this.mapNetworkResponse(this.mappingService.listLanguagesResponse(response.data), response);
    });
  }
  /**
   * Gets single taxonomy from given url
   * @param url Url used to get single taxonomy
   * @param queryConfig Query configuration
   */
  getTaxonomy(url, queryConfig) {
    return __awaiter4(this, void 0, void 0, function* () {
      const response = yield this.getResponseAsync(url, queryConfig);
      return this.mapNetworkResponse(this.mappingService.viewTaxonomyResponse(response.data), response);
    });
  }
  /**
   * Gets multiple taxonomies from given url
   * @param url Url used to get multiple taxonomies
   * @param queryConfig Query configuration
   */
  getTaxonomies(url, queryConfig) {
    return __awaiter4(this, void 0, void 0, function* () {
      const response = yield this.getResponseAsync(url, queryConfig);
      return this.mapNetworkResponse(this.mappingService.listTaxonomiesResponse(response.data), response);
    });
  }
  /**
   * Gets single content type element from given url
   * @param url Url used to get single content type element
   * @param queryConfig Query configuration
   */
  getElementAsync(url, queryConfig) {
    return __awaiter4(this, void 0, void 0, function* () {
      const response = yield this.getResponseAsync(url, queryConfig);
      return this.mapNetworkResponse(this.mappingService.viewContentTypeElementResponse(response.data), response);
    });
  }
  getListAllResponse(data) {
    return __awaiter4(this, void 0, void 0, function* () {
      const responses = yield this.getListAllResponseInternalAsync({
        page: data.page,
        resolvedResponses: [],
        getResponse: data.getResponse,
        nextPageUrl: void 0,
        continuationToken: void 0,
        listQueryConfig: data.listQueryConfig
      });
      return data.allResponseFactory(responses.reduce((prev, current) => {
        prev.push(...current.data.items);
        return prev;
      }, []), responses);
    });
  }
  getListAllResponseInternalAsync(data) {
    var _a, _b, _c, _d;
    return __awaiter4(this, void 0, void 0, function* () {
      if ((_a = data.listQueryConfig) === null || _a === void 0 ? void 0 : _a.pages) {
        if (data.page > data.listQueryConfig.pages) {
          return data.resolvedResponses;
        }
      }
      const response = yield data.getResponse(data.nextPageUrl, data.continuationToken);
      if ((_b = data.listQueryConfig) === null || _b === void 0 ? void 0 : _b.delayBetweenRequests) {
        yield this.sleep(data.listQueryConfig.delayBetweenRequests);
      }
      data.resolvedResponses.push(response);
      if ((_c = data.listQueryConfig) === null || _c === void 0 ? void 0 : _c.responseFetched) {
        data.listQueryConfig.responseFetched(response, data.nextPageUrl, data.continuationToken);
      }
      const nextPage = (_d = response.data.pagination) === null || _d === void 0 ? void 0 : _d.nextPage;
      const continuationToken = response.xContinuationToken;
      if (nextPage || continuationToken) {
        return yield this.getListAllResponseInternalAsync({
          page: data.page + 1,
          nextPageUrl: nextPage,
          continuationToken,
          listQueryConfig: data.listQueryConfig,
          getResponse: data.getResponse,
          resolvedResponses: data.resolvedResponses
        });
      }
      return data.resolvedResponses;
    });
  }
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/utilities/linked-items.helper.js
var LinkedItemsHelper = class {
  convertLinkedItemsToArray(linkedItems) {
    const linkedItemsArray = [];
    for (const linkedItemKey of Object.keys(linkedItems)) {
      linkedItemsArray.push(linkedItems[linkedItemKey]);
    }
    return linkedItemsArray;
  }
};
var linkedItemsHelper = new LinkedItemsHelper();

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
var i;
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@kontent-ai/delivery-sdk/dist/es6/utilities/guid.helper.js
var GuidHelper = class {
  genereateGuid() {
    return v4_default();
  }
};
var guidHelper = new GuidHelper();

// node_modules/@kontent-ai/delivery-sdk/dist/es6/utilities/delivery-url.helper.js
var urlParse = __toESM(require_url_parse());
var DeliveryUrlHelper = class {
  replaceAssetDomain(originalAssetUrl, customDomain) {
    const urlPath = this.getUrlPathname(originalAssetUrl);
    return `${customDomain}${urlPath}`;
  }
  getUrlPathname(url) {
    const parsedUrl = urlParse(url);
    return parsedUrl.pathname;
  }
};
var deliveryUrlHelper = new DeliveryUrlHelper();

// node_modules/@kontent-ai/delivery-sdk/dist/es6/utilities/text.helper.js
var TextHelper = class {
  getPropertyNameRegex() {
    return /[+;,/&()?\-='"\\\xa7!%:_\s.]+(.)?/g;
  }
  removeZeroWidthCharacters(str) {
    return str.replace(/[\u200B-\u200D\uFEFF]/g, "");
  }
  addUnderscoreWhenStarsWithNumber(str) {
    if (this.startsWithNumber(str)) {
      return `_${str}`;
    }
    return str;
  }
  startsWithNumber(str) {
    if (str.match(/^\d/)) {
      return true;
    }
    return false;
  }
};
var textHelper = new TextHelper();

// node_modules/@kontent-ai/delivery-sdk/dist/es6/utilities/enum.helper.js
var EnumHelper = class {
  getAllValues(T) {
    const allEnumValues = Object.keys(T).map((key) => T[key]);
    return allEnumValues;
  }
  getEnumFromValue(T, value) {
    try {
      if (!value) {
        return void 0;
      }
      if (this.isNumeric(value)) {
        return T[value];
      }
      const allEnumValues = this.getAllValues(T);
      const result = allEnumValues.find((m) => m.toLowerCase() === value.toString().toLowerCase());
      if (!result) {
        return void 0;
      }
      return result;
    } catch (err) {
      return void 0;
    }
  }
  isNumeric(value) {
    return !isNaN(parseFloat(value)) && isFinite(value);
  }
};
var enumHelper = new EnumHelper();

// node_modules/@kontent-ai/delivery-sdk/dist/es6/utilities/codename.helper.js
var CodenameHelper = class {
  /**
   * This is used to prevent errors caused by reserved names in content item codename (e.g. 'constructor')
   */
  escapeCodenameInCodenameIndexer(codename) {
    return `_${codename}`;
  }
};
var codenameHelper = new CodenameHelper();

// node_modules/@kontent-ai/delivery-sdk/dist/es6/mappers/element.mapper.js
var ElementMapper = class {
  constructor(config) {
    this.config = config;
  }
  mapElements(data) {
    const processedItem = data.processedItems[codenameHelper.escapeCodenameInCodenameIndexer(data.dataToMap.item.system.codename)];
    if (processedItem) {
      return {
        item: processedItem,
        processedItems: data.processedItems,
        preparedItems: data.preparedItems,
        processingStartedForCodenames: data.processingStartedForCodenames
      };
    }
    const preparedItem = data.preparedItems[codenameHelper.escapeCodenameInCodenameIndexer(data.dataToMap.item.system.codename)];
    const itemInstance = preparedItem === null || preparedItem === void 0 ? void 0 : preparedItem.item;
    if (!itemInstance) {
      return void 0;
    }
    const elementCodenames = Object.getOwnPropertyNames(data.dataToMap.rawItem.elements);
    for (const elementCodename of elementCodenames) {
      const elementMap = this.resolveElementMap(itemInstance, elementCodename);
      const elementWrapper = {
        system: data.dataToMap.item.system,
        rawElement: data.dataToMap.rawItem.elements[elementCodename],
        element: elementMap.resolvedName
      };
      if (elementMap.shouldMapElement) {
        const mappedElement = this.mapElement({
          elementWrapper,
          item: itemInstance,
          preparedItems: data.preparedItems,
          processingStartedForCodenames: data.processingStartedForCodenames,
          processedItems: data.processedItems
        });
        itemInstance.elements[elementMap.resolvedName] = mappedElement;
      }
    }
    return {
      item: itemInstance,
      processedItems: data.processedItems,
      preparedItems: data.preparedItems,
      processingStartedForCodenames: data.processingStartedForCodenames
    };
  }
  mapElement(data) {
    const elementType = enumHelper.getEnumFromValue(ElementType, data.elementWrapper.rawElement.type);
    if (elementType) {
      if (elementType === ElementType.ModularContent) {
        return this.mapLinkedItemsElement({
          elementWrapper: data.elementWrapper,
          preparedItems: data.preparedItems,
          processingStartedForCodenames: data.processingStartedForCodenames,
          processedItems: data.processedItems
        });
      }
      if (elementType === ElementType.Text) {
        return this.mapTextElement(data.elementWrapper);
      }
      if (elementType === ElementType.Asset) {
        return this.mapAssetsElement(data.elementWrapper);
      }
      if (elementType === ElementType.Number) {
        return this.mapNumberElement(data.elementWrapper);
      }
      if (elementType === ElementType.MultipleChoice) {
        return this.mapMultipleChoiceElement(data.elementWrapper);
      }
      if (elementType === ElementType.DateTime) {
        return this.mapDateTimeElement(data.elementWrapper);
      }
      if (elementType === ElementType.RichText) {
        return this.mapRichTextElement(data.elementWrapper, data.processedItems, data.processingStartedForCodenames, data.preparedItems);
      }
      if (elementType === ElementType.UrlSlug) {
        return this.mapUrlSlugElement(data.elementWrapper);
      }
      if (elementType === ElementType.Taxonomy) {
        return this.mapTaxonomyElement(data.elementWrapper);
      }
      if (elementType === ElementType.Custom) {
        return this.mapCustomElement(data.elementWrapper);
      }
    }
    console.warn(`Could not map element '${data.elementWrapper.rawElement.name}' of type '${data.elementWrapper.rawElement.type}'. Returning unknown element instead.`);
    return this.mapUnknowElement(data.elementWrapper);
  }
  mapRichTextElement(elementWrapper, processedItems, processingStartedForCodenames, preparedItems) {
    const rawElement = elementWrapper.rawElement;
    const richTextLinkedItems = [];
    const richTextLinkedItemsCodenames = [];
    const rawModularContentCodenamesMatches = rawElement.value.matchAll(/<object[^>]+data-codename="(?<codename>[a-z0-9_]*)".*?>/g);
    const rawModularContentCodenamesSorted = Array.from(rawModularContentCodenamesMatches).reduce((acc, match) => {
      if (match.groups && match.groups.codename) {
        acc.push(match.groups.codename);
      }
      return acc;
    }, []);
    const rawModularContentCodenames = [...rawElement.modular_content].sort(function(a, b) {
      return rawModularContentCodenamesSorted.indexOf(a) - rawModularContentCodenamesSorted.indexOf(b);
    });
    for (const codename of rawModularContentCodenames) {
      richTextLinkedItemsCodenames.push(codename);
      const preparedData = preparedItems[codename];
      if (this.canMapLinkedItems()) {
        const existingLinkedItem = this.getOrSaveLinkedItemForElement(codename, rawElement, processedItems, processingStartedForCodenames, preparedItems);
        if (existingLinkedItem) {
          richTextLinkedItems.push(existingLinkedItem);
        } else {
          if (preparedData) {
            const mappedLinkedItemResult = this.mapElements({
              dataToMap: preparedData,
              preparedItems,
              processingStartedForCodenames,
              processedItems
            });
            if (mappedLinkedItemResult) {
              richTextLinkedItems.push(mappedLinkedItemResult.item);
            }
          }
        }
      }
    }
    const richTextImagesResult = this.getRichTextImages(rawElement.images);
    const links = this.mapRichTextLinks(rawElement.links);
    const images = richTextImagesResult.richTextImages;
    const richTextHtml = this.getRichTextHtml(rawElement.value, richTextImagesResult.imageUrlRecords);
    return {
      images,
      linkedItemCodenames: richTextLinkedItemsCodenames,
      linkedItems: richTextLinkedItems,
      links,
      name: rawElement.name,
      type: ElementType.RichText,
      value: richTextHtml
    };
  }
  mapDateTimeElement(elementWrapper) {
    var _a;
    const rawElement = elementWrapper.rawElement;
    return Object.assign(Object.assign({}, this.buildElement(elementWrapper, ElementType.DateTime, () => rawElement.value)), { displayTimeZone: (_a = rawElement.display_timezone) !== null && _a !== void 0 ? _a : null });
  }
  mapMultipleChoiceElement(elementWrapper) {
    return this.buildElement(elementWrapper, ElementType.MultipleChoice, () => elementWrapper.rawElement.value);
  }
  mapNumberElement(elementWrapper) {
    return this.buildElement(elementWrapper, ElementType.Number, () => {
      if (elementWrapper.rawElement.value === 0) {
        return 0;
      } else if (elementWrapper.rawElement.value) {
        return +elementWrapper.rawElement.value;
      }
      return null;
    });
  }
  mapTextElement(elementWrapper) {
    return this.buildElement(elementWrapper, ElementType.Text, () => elementWrapper.rawElement.value);
  }
  mapAssetsElement(elementWrapper) {
    return this.buildElement(elementWrapper, ElementType.Asset, () => {
      var _a;
      const assetContracts = elementWrapper.rawElement.value;
      const assets = [];
      for (const assetContract of assetContracts) {
        let renditions = null;
        const assetUrl = this.config.assetsDomain ? deliveryUrlHelper.replaceAssetDomain(assetContract.url, this.config.assetsDomain) : assetContract.url;
        if (assetContract.renditions) {
          renditions = {};
          for (const renditionPresetKey of Object.keys(assetContract.renditions)) {
            const rendition = assetContract.renditions[renditionPresetKey];
            renditions[renditionPresetKey] = Object.assign(Object.assign({}, rendition), {
              url: `${assetUrl}?${rendition.query}`
              // enhance rendition with absolute url
            });
          }
        }
        const renditionToBeApplied = this.config.defaultRenditionPreset && (renditions === null || renditions === void 0 ? void 0 : renditions[this.config.defaultRenditionPreset]) || null;
        const finalUrl = (_a = renditionToBeApplied === null || renditionToBeApplied === void 0 ? void 0 : renditionToBeApplied.url) !== null && _a !== void 0 ? _a : assetUrl;
        const asset = Object.assign(Object.assign({}, assetContract), {
          url: finalUrl,
          // use custom url of asset which may contain custom domain and applied rendition
          renditions
        });
        assets.push(asset);
      }
      return assets;
    });
  }
  mapTaxonomyElement(elementWrapper) {
    var _a;
    return Object.assign(Object.assign({}, this.buildElement(elementWrapper, ElementType.Taxonomy, () => elementWrapper.rawElement.value)), { taxonomyGroup: (_a = elementWrapper.rawElement.taxonomy_group) !== null && _a !== void 0 ? _a : null });
  }
  mapUnknowElement(elementWrapper) {
    return this.buildElement(elementWrapper, ElementType.Unknown, () => elementWrapper.rawElement.value);
  }
  mapCustomElement(elementWrapper) {
    if (this.config.elementResolver) {
      const elementResolverValue = this.config.elementResolver(elementWrapper);
      if (elementResolverValue) {
        return this.buildElement(elementWrapper, ElementType.Custom, () => elementResolverValue);
      }
    }
    return this.buildElement(elementWrapper, ElementType.Custom, () => elementWrapper.rawElement.value);
  }
  mapUrlSlugElement(elementWrapper) {
    return this.buildElement(elementWrapper, ElementType.UrlSlug, () => elementWrapper.rawElement.value);
  }
  mapLinkedItemsElement(data) {
    const linkedItems = [];
    const linkedItemCodenames = data.elementWrapper.rawElement.value;
    for (const codename of linkedItemCodenames) {
      if (this.canMapLinkedItems()) {
        const linkedItem = this.getOrSaveLinkedItemForElement(codename, data.elementWrapper.rawElement, data.processedItems, data.processingStartedForCodenames, data.preparedItems);
        if (linkedItem) {
          linkedItems.push(linkedItem);
        }
      }
    }
    return Object.assign(Object.assign({}, this.buildElement(data.elementWrapper, ElementType.ModularContent, () => linkedItemCodenames)), { linkedItems });
  }
  getOrSaveLinkedItemForElement(codename, element, processedItems, mappingStartedForCodenames, preparedItems) {
    const escapedCodename = codenameHelper.escapeCodenameInCodenameIndexer(codename);
    const processedItem = processedItems[escapedCodename];
    if (processedItem) {
      return processedItem;
    }
    const preparedItem = preparedItems[escapedCodename];
    if (mappingStartedForCodenames.includes(codename)) {
      return preparedItem === null || preparedItem === void 0 ? void 0 : preparedItem.item;
    }
    mappingStartedForCodenames.push(codename);
    if (!preparedItem) {
      return void 0;
    }
    let mappedLinkedItem;
    const mappedLinkedItemResult = this.mapElements({
      dataToMap: preparedItem,
      preparedItems,
      processingStartedForCodenames: mappingStartedForCodenames,
      processedItems
    });
    if (mappedLinkedItemResult) {
      mappedLinkedItem = mappedLinkedItemResult.item;
      processedItems[escapedCodename] = mappedLinkedItem;
    }
    return mappedLinkedItem;
  }
  mapRichTextLinks(linksJson) {
    const links = [];
    for (const linkId of Object.keys(linksJson)) {
      const linkRaw = linksJson[linkId];
      links.push({
        codename: linkRaw.codename,
        linkId,
        urlSlug: linkRaw.url_slug,
        type: linkRaw.type
      });
    }
    return links;
  }
  getRichTextHtml(richTextHtml, richTextImageRecords) {
    for (const richTextImageRecord of richTextImageRecords) {
      if (richTextImageRecord.newUrl !== richTextImageRecord.originalUrl) {
        richTextHtml = richTextHtml.replace(new RegExp(richTextImageRecord.originalUrl, "g"), richTextImageRecord.newUrl);
      }
    }
    return richTextHtml;
  }
  getRichTextImages(imagesJson) {
    var _a, _b, _c;
    const images = [];
    const imageUrlRecords = [];
    for (const imageId of Object.keys(imagesJson)) {
      const imageRaw = imagesJson[imageId];
      const imageUrl = this.config.assetsDomain ? deliveryUrlHelper.replaceAssetDomain(imageRaw.url, this.config.assetsDomain) : imageRaw.url;
      images.push({
        description: (_a = imageRaw.description) !== null && _a !== void 0 ? _a : null,
        imageId: imageRaw.image_id,
        url: imageUrl,
        height: (_b = imageRaw.height) !== null && _b !== void 0 ? _b : null,
        width: (_c = imageRaw.width) !== null && _c !== void 0 ? _c : null
      });
      imageUrlRecords.push({
        originalUrl: imageRaw.url,
        newUrl: imageUrl
      });
    }
    return {
      imageUrlRecords,
      richTextImages: images
    };
  }
  resolveElementMap(item, originalElementCodename) {
    let resolvedElementPropertyName = void 0;
    if (this.config.propertyNameResolver) {
      resolvedElementPropertyName = this.config.propertyNameResolver(item.system.type, originalElementCodename);
    }
    if (!resolvedElementPropertyName) {
      resolvedElementPropertyName = originalElementCodename;
    }
    return {
      resolvedName: resolvedElementPropertyName,
      shouldMapElement: true
    };
  }
  buildElement(elementWrapper, type, valueFactory) {
    return {
      name: elementWrapper.rawElement.name,
      type,
      value: valueFactory()
    };
  }
  canMapLinkedItems() {
    if (!this.config.linkedItemsReferenceHandler) {
      return true;
    }
    return this.config.linkedItemsReferenceHandler === "map";
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/mappers/item.mapper.js
var ItemMapper = class {
  constructor(config) {
    this.config = config;
    this.elementMapper = new ElementMapper(config);
  }
  /**
   * Maps single item to its proper strongly typed model from the given response
   * @param response Response used to map the item
   * @param queryConfig Query configuration
   */
  mapSingleItemFromResponse(response) {
    const mapResult = this.mapItems({
      mainItems: [response.item],
      linkedItems: Object.values(response.modular_content)
    });
    return {
      item: mapResult.items[0],
      linkedItems: mapResult.linkedItems
    };
  }
  /**
   * Maps multiple items to their strongly typed model from the given  response
   * @param response Response used to map the item
   * @param queryConfig Query configuration
   */
  mapMultipleItemsFromResponse(response) {
    const mapResult = this.mapItems({
      mainItems: response.items,
      linkedItems: Object.values(response.modular_content)
    });
    return mapResult;
  }
  /**
   * Maps item contracts to full models
   */
  mapItems(data) {
    const processedItems = {};
    const preparedItems = {};
    const processingStartedForCodenames = [];
    const mappedMainItems = [];
    const mappedLinkedItems = {};
    const itemsToResolve = [...data.mainItems, ...data.linkedItems];
    for (const item of itemsToResolve) {
      preparedItems[codenameHelper.escapeCodenameInCodenameIndexer(item.system.codename)] = {
        item: this.createContentItem(item),
        rawItem: item
      };
    }
    for (const item of data.mainItems) {
      const itemResult = this.mapItem({
        item: preparedItems[codenameHelper.escapeCodenameInCodenameIndexer(item.system.codename)],
        processedItems,
        preparedItems,
        processingStartedForCodenames
      });
      mappedMainItems.push(itemResult.item);
    }
    for (const item of data.linkedItems) {
      const itemResult = this.mapItem({
        item: preparedItems[codenameHelper.escapeCodenameInCodenameIndexer(item.system.codename)],
        processedItems,
        preparedItems,
        processingStartedForCodenames
      });
      mappedLinkedItems[item.system.codename] = itemResult.item;
    }
    return {
      items: mappedMainItems,
      linkedItems: mappedLinkedItems
    };
  }
  /**
   * Maps item contract to full model
   */
  mapItem(data) {
    if (!data.item) {
      throw Error(`Could not map item because its undefined`);
    }
    const result = this.elementMapper.mapElements({
      dataToMap: data.item,
      preparedItems: data.preparedItems,
      processingStartedForCodenames: [],
      processedItems: data.processedItems
    });
    if (!result) {
      throw Error(`Mapping of content item '${data.item.item.system.codename}' failed`);
    }
    return {
      item: result.item,
      processedItems: result.processedItems,
      preparedItems: result.preparedItems,
      processingStartedForCodenames: result.processingStartedForCodenames
    };
  }
  createContentItem(item) {
    var _a, _b;
    const contentItem = {
      elements: {},
      system: {
        codename: item.system.codename,
        collection: item.system.collection,
        id: item.system.id,
        language: item.system.language,
        lastModified: item.system.last_modified,
        name: item.system.name,
        sitemapLocations: item.system.sitemap_locations,
        type: item.system.type,
        workflowStep: (_a = item.system.workflow_step) !== null && _a !== void 0 ? _a : null,
        workflow: (_b = item.system.workflow) !== null && _b !== void 0 ? _b : null
      }
    };
    return contentItem;
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/mappers/taxonomy.mapper.js
var TaxonomyMapper = class {
  mapTaxonomy(taxonomySystem, taxonomyTerms) {
    if (!taxonomySystem) {
      throw Error(`Cannot map taxonomy due to missing 'system' property`);
    }
    if (!taxonomyTerms) {
      throw Error(`Cannot map taxonomy due to missing 'terms' property`);
    }
    if (!Array.isArray(taxonomyTerms)) {
      throw Error(`Cannot map terms because no terms array was provided`);
    }
    const mappedSystemAttributes = {
      name: taxonomySystem.name,
      codename: taxonomySystem.codename,
      id: taxonomySystem.id,
      lastModified: taxonomySystem.last_modified
    };
    const mappedTerms = this.mapTaxonomyTerms(taxonomyTerms);
    return {
      system: mappedSystemAttributes,
      terms: mappedTerms
    };
  }
  mapTaxonomies(taxonomies) {
    if (!taxonomies) {
      throw Error(`Cannot map taxonomy due to missing 'taxonomies' property`);
    }
    if (!Array.isArray(taxonomies)) {
      throw Error(`Cannot map taxonomies because the 'taxonomies' property is not an array `);
    }
    const mappedTaxonomies = [];
    taxonomies.forEach((taxonomy) => {
      mappedTaxonomies.push(this.mapTaxonomy(taxonomy.system, taxonomy.terms));
    });
    return mappedTaxonomies;
  }
  /**
   * Recursively map array of taxonomy terms
   * @param termsArray Terms array to map
   */
  mapTaxonomyTerms(termsArray) {
    if (termsArray.length === 0) {
      return [];
    }
    const mappedTermsArray = [];
    termsArray.forEach((terms) => {
      const mappedTerms = {
        codename: terms.codename,
        name: terms.name,
        terms: this.mapTaxonomyTerms(terms.terms)
      };
      mappedTermsArray.push(mappedTerms);
    });
    return mappedTermsArray;
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/mappers/type.mapper.js
var TypeMapper = class {
  mapSingleType(response) {
    return this.mapType(response);
  }
  mapMultipleTypes(response) {
    return response.types.map((type) => {
      return this.mapType(type);
    });
  }
  mapType(type) {
    if (!type) {
      throw Error(`Cannot map type`);
    }
    if (!type.elements) {
      throw Error(`Cannot map type elements`);
    }
    const system = {
      codename: type.system.codename,
      id: type.system.id,
      name: type.system.name,
      lastModified: type.system.last_modified
    };
    const elements = [];
    const elementNames = Object.getOwnPropertyNames(type.elements);
    elementNames.forEach((elementName) => {
      const typeElement = type.elements[elementName];
      if (!typeElement) {
        throw Error(`Cannot find element '${elementName}' on type '${type.system.codename}'`);
      }
      const elementCodename = elementName;
      const options = [];
      const rawOptions = typeElement.options;
      if (rawOptions) {
        if (!Array.isArray(rawOptions)) {
          throw Error(`Content type 'options' property has to be an array`);
        }
        rawOptions.forEach((rawOption) => {
          options.push({
            codename: rawOption.codename,
            name: rawOption.name
          });
        });
      }
      elements.push({
        codename: elementCodename,
        taxonomyGroup: typeElement.taxonomy_group,
        options,
        name: typeElement.name,
        type: typeElement.type
      });
    });
    return {
      elements,
      system
    };
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/mappers/generic-element.mapper.js
var GenericElementMapper = class {
  mapElement(response) {
    if (!response) {
      throw Error(`Invalid response for mapping element`);
    }
    const element = response;
    return {
      codename: element.codename,
      name: element.name,
      type: element.type,
      options: element.options ? element.options : [],
      taxonomyGroup: element.taxonomy_group
    };
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/mappers/language.mapper.js
var LanguageMapper = class {
  mapMultipleLanguages(response) {
    return response.languages.map((language) => {
      return this.mapLanguage(language);
    });
  }
  mapLanguage(language) {
    if (!language) {
      throw Error(`Cannot map language`);
    }
    return {
      system: language.system
    };
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/mappers/sync.mapper.js
var SyncMapper = class {
  mapContentItemDelta(itemDeltaContract) {
    var _a, _b;
    const systemContract = itemDeltaContract.data.system;
    const elements = itemDeltaContract.data.elements ? itemDeltaContract.data.elements : {};
    return {
      changeType: itemDeltaContract.change_type,
      timestamp: itemDeltaContract.timestamp,
      data: {
        elements,
        system: {
          codename: systemContract.codename,
          collection: systemContract.collection,
          id: systemContract.id,
          language: systemContract.language,
          lastModified: systemContract.last_modified,
          name: systemContract.name,
          sitemapLocations: systemContract.sitemap_locations,
          type: systemContract.type,
          workflowStep: (_a = systemContract.workflow_step) !== null && _a !== void 0 ? _a : null,
          workflow: (_b = systemContract.workflow) !== null && _b !== void 0 ? _b : null
        }
      }
    };
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/services/mapping.service.js
var MappingService = class {
  constructor(config) {
    this.config = config;
    this.typeMapper = new TypeMapper();
    this.languageMapper = new LanguageMapper();
    this.itemMapper = new ItemMapper(config);
    this.taxonomyMapper = new TaxonomyMapper();
    this.genericElementMapper = new GenericElementMapper();
    this.syncMapper = new SyncMapper();
  }
  /**
   * Gets response for list of languages
   * @param data Response data
   */
  listLanguagesResponse(data) {
    return {
      items: this.languageMapper.mapMultipleLanguages(data),
      pagination: this.mapPagination(data.pagination)
    };
  }
  /**
   * Gets response for getting a multiple type
   * @param data Response data
   */
  listContentTypesResponse(data) {
    return {
      items: this.typeMapper.mapMultipleTypes(data),
      pagination: this.mapPagination(data.pagination)
    };
  }
  /**
   * Gets response for single type
   * @param data Response data
   * @param options Options
   */
  viewContentTypeResponse(data) {
    return {
      type: this.typeMapper.mapSingleType(data)
    };
  }
  itemsFeedResponse(data) {
    const itemsResult = this.itemMapper.mapItems({
      linkedItems: Object.values(data.modular_content),
      mainItems: data.items
    });
    return {
      items: itemsResult.items,
      linkedItems: itemsResult.linkedItems
    };
  }
  /**
   * Gets response for getting single item
   * @param data Response data
   * @param queryConfig Query configuration
   */
  viewContentItemResponse(data) {
    const itemResult = this.itemMapper.mapSingleItemFromResponse(data);
    return {
      item: itemResult.item,
      linkedItems: itemResult.linkedItems
    };
  }
  /**
   * Gets response for getting multiple items
   * @param data Response data
   * @param queryConfig Query configuration
   */
  listContentItemsResponse(data) {
    const itemsResult = this.itemMapper.mapMultipleItemsFromResponse(data);
    return {
      items: itemsResult.items,
      pagination: this.mapPagination(data.pagination),
      linkedItems: itemsResult.linkedItems
    };
  }
  /**
   * Gets response for getting single taxonomy item
   * @param data Response data
   */
  viewTaxonomyResponse(data) {
    return {
      taxonomy: this.taxonomyMapper.mapTaxonomy(data.system, data.terms)
    };
  }
  /**
   * Gets response for getting multiples taxonomies
   * @param data Response data
   */
  listTaxonomiesResponse(data) {
    return {
      items: this.taxonomyMapper.mapTaxonomies(data.taxonomies),
      pagination: this.mapPagination(data.pagination)
    };
  }
  /**
   * Gets response for getting single content type element
   * @param data Response data
   */
  viewContentTypeElementResponse(data) {
    return this.genericElementMapper.mapElement(data);
  }
  initializeContentSync(data) {
    return {
      items: data.items.map((m) => this.syncMapper.mapContentItemDelta(m))
    };
  }
  syncChanges(data) {
    return {
      items: data.items.map((m) => this.syncMapper.mapContentItemDelta(m))
    };
  }
  mapPagination(paginationContract) {
    var _a;
    return {
      skip: paginationContract.skip,
      count: paginationContract.count,
      limit: paginationContract.limit,
      nextPage: paginationContract.next_page,
      totalCount: (_a = paginationContract.total_count) !== null && _a !== void 0 ? _a : null
    };
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/client/delivery-client.js
var DeliveryClient = class {
  /**
   * Delivery client used to fetch data from Kontent.ai
   * @constructor
   * @param {IDeliveryClientConfig} config - The client configuration
   */
  constructor(config) {
    this.config = config;
    if (!config) {
      throw Error(`Delivery client configuration is not set`);
    }
    this.mappingService = new MappingService(config);
    this.queryService = new QueryService(config, config.httpService ? config.httpService : new HttpService(), {
      host: sdkInfo.host,
      name: sdkInfo.name,
      version: sdkInfo.version
    }, this.mappingService);
  }
  /**
   * Gets query for multiple languages
   */
  languages() {
    return new LanguagesQuery(this.config, this.queryService);
  }
  /**
   * Gets query for multiple types
   */
  types() {
    return new MultipleTypeQuery(this.config, this.queryService);
  }
  /**
   * Gets query for single type
   * @param {string} typeCodename - Codename of the type to fetch
   */
  type(typeCodename) {
    return new SingleTypeQuery(this.config, this.queryService, typeCodename);
  }
  /**
   * Gets query for multiple items
   */
  items() {
    return new MultipleItemsQuery(this.config, this.queryService);
  }
  /**
   * Gets query for single item
   * @param {string} codename - Codename of item to fetch
   */
  item(codename) {
    return new SingleItemQuery(this.config, this.queryService, codename);
  }
  /**
   * Gets query for items feed. Executes single HTTP request only
   */
  itemsFeed() {
    return new ItemsFeedQuery(this.config, this.queryService);
  }
  /**
   * Gets query for single taxonomy
   * @param {string} codename - Codename of taxonomy to fetch
   */
  taxonomy(codename) {
    return new TaxonomyQuery(this.config, this.queryService, codename);
  }
  /**
   * Gets query for multiple taxonomies
   */
  taxonomies() {
    return new TaxonomiesQuery(this.config, this.queryService);
  }
  /**
   * Gets query for an element within a type
   * @param {string} typeCodename - Codename of the type
   * @param {string} elementCodename - Codename of the element
   */
  element(typeCodename, elementCodename) {
    return new ElementQuery(this.config, this.queryService, typeCodename, elementCodename);
  }
  /**
   * Gets query for initializing sync
   */
  initializeSync() {
    return new InitializeSyncQuery(this.config, this.queryService);
  }
  /**
   * Gets query fetching delta updates of content items
   */
  syncChanges() {
    return new SyncChangesQuery(this.config, this.queryService);
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/client/delivery-client.factory.js
function createDeliveryClient(config) {
  return new DeliveryClient(config);
}

// node_modules/@kontent-ai/delivery-sdk/dist/es6/parser/parse-models.js
var ParsedItemIndexReferenceWrapper = class {
  constructor(index) {
    this.index = index;
  }
  increment() {
    this.index++;
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/parser/parser-configuration.js
var parserConfiguration = {
  linkedItemWrapperElem: "div",
  modularContentElementData: {
    type: "application/kenticocloud",
    dataType: "data-type",
    dataCodename: "data-codename",
    relAttribute: "data-rel",
    componentRel: "component"
  },
  linkElementData: {
    nodeName: "a",
    dataItemId: "data-item-id"
  },
  imageElementData: {
    nodeName: "img",
    dataImageId: "data-image-id",
    srcAttribute: "src"
  },
  resolvedLinkedItemIndexAttribute: "data-sdk-item-index",
  resolvedAttribute: "data-sdk-resolved"
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/parser/parser.helper.js
var ParserHelper = class {
  constructor() {
    this.sdkResolvedAttributeName = "data-sdk-resolved";
  }
  getLinkedItem(linkedItems, itemCodename) {
    if (!linkedItems) {
      return void 0;
    }
    return linkedItems.find((m) => m.system.codename === itemCodename);
  }
  tryGetImage(inputElement, linkedItems, imageId) {
    const elementImage = inputElement.images.find((m) => m.imageId === imageId);
    if (elementImage) {
      return elementImage;
    }
    if (linkedItems) {
      for (const linkedItem of linkedItems) {
        for (const elementKey of Object.keys(linkedItem.elements)) {
          const element = linkedItem.elements[elementKey];
          if (element.type === ElementType.RichText) {
            const richTextElement = element;
            const richTextElementImage = richTextElement.images.find((m) => m.imageId === imageId);
            if (richTextElementImage) {
              return richTextElementImage;
            }
          }
        }
      }
    }
    return void 0;
  }
  tryGetLink(inputElement, linkedItems, linkId) {
    const elementLink = inputElement.links.find((m) => m.linkId === linkId);
    if (elementLink) {
      return elementLink;
    }
    if (linkedItems) {
      for (const linkedItem of linkedItems) {
        for (const elementKey of Object.keys(linkedItem.elements)) {
          const element = linkedItem.elements[elementKey];
          if (element.type === ElementType.RichText) {
            const richTextElement = element;
            const richTextElementLink = richTextElement.links.find((m) => m.linkId === linkId);
            if (richTextElementLink) {
              return richTextElementLink;
            }
          }
        }
      }
    }
    return void 0;
  }
  convertToParserElement(element) {
    const attributes = [];
    for (let i = 0; i < element.attributes.length; i++) {
      const attribute = element.attributes[i];
      attributes.push({
        name: attribute.name,
        value: attribute.value
      });
    }
    return {
      tag: element.tagName,
      setAttribute: (attributeName, attributeValue) => {
        const attribute = element.attributes.getNamedItem(attributeName);
        if (attribute) {
          attribute.value = attributeValue !== null && attributeValue !== void 0 ? attributeValue : "";
        } else {
          element.setAttribute(attributeName, attributeValue !== null && attributeValue !== void 0 ? attributeValue : "");
        }
      },
      setInnerHtml: (newHtml) => element.innerHTML = newHtml,
      setOuterHtml: (newHtml) => element.outerHTML = newHtml,
      html: element.innerHTML,
      text: element.textContent ? element.textContent : void 0,
      attributes,
      parentElement: element.parentElement ? this.convertToParserElement(element.parentElement) : void 0,
      sourceElement: element
    };
  }
};
var parserHelper = new ParserHelper();

// node_modules/@kontent-ai/delivery-sdk/dist/es6/parser/implementation/async-browser-parser.class.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AsyncBrowserParser = class {
  parseAsync(html, mainRichTextElement, resolvers2, linkedItems) {
    return __awaiter5(this, void 0, void 0, function* () {
      return yield this.parseInternalAsync(mainRichTextElement, resolvers2, html, linkedItems, new ParsedItemIndexReferenceWrapper(0), null);
    });
  }
  parseInternalAsync(mainRichTextElement, resolvers2, html, linkedItems, linkedItemIndex, parentElement) {
    return __awaiter5(this, void 0, void 0, function* () {
      const rootElement = this.createWrapperElement(html);
      const result = yield this.processRichTextElementAsync(mainRichTextElement, resolvers2, rootElement.children, {
        links: [],
        linkedItems: [],
        images: []
      }, linkedItems, linkedItemIndex, parentElement);
      return {
        componentCodenames: result.linkedItems.filter((m) => m.itemType === "component").map((m) => m.dataCodename),
        linkedItemCodenames: result.linkedItems.filter((m) => m.itemType === "linkedItem").map((m) => m.dataCodename),
        result: rootElement.innerHTML
      };
    });
  }
  processRichTextElementAsync(mainRichTextElement, resolvers2, htmlCollection, result, linkedItems, linkedItemIndex, parentElement) {
    return __awaiter5(this, void 0, void 0, function* () {
      if (!htmlCollection || htmlCollection.length === 0) {
      } else {
        for (let i = 0; i < htmlCollection.length; i++) {
          const element = htmlCollection[i];
          yield resolvers2.elementResolverAsync(parserHelper.convertToParserElement(element));
          const typeAttribute = element.attributes ? element.attributes.getNamedItem("type") : void 0;
          if (element.attributes && typeAttribute && typeAttribute.value && typeAttribute.value.toLowerCase() === parserConfiguration.modularContentElementData.type.toLowerCase()) {
            const dataCodenameAttribute = element.attributes.getNamedItem(parserConfiguration.modularContentElementData.dataCodename);
            const dataTypeAttribute = element.attributes.getNamedItem(parserConfiguration.modularContentElementData.dataType);
            if (!dataTypeAttribute) {
              throw Error("Missing data type attribute. This is likely an error caused by invalid response.");
            }
            const relAttribute = element.attributes.getNamedItem(parserConfiguration.modularContentElementData.relAttribute);
            let itemType = "linkedItem";
            if (relAttribute && relAttribute.value === parserConfiguration.modularContentElementData.componentRel) {
              itemType = "component";
            }
            const linkItemContentObject = {
              dataCodename: dataCodenameAttribute ? dataCodenameAttribute.value : "",
              dataType: dataTypeAttribute ? dataTypeAttribute.value : "",
              itemType
            };
            const elementParent = element.parentElement;
            if (!elementParent) {
              console.warn(`Could not replace linked item '${linkItemContentObject.dataCodename}' of '${linkItemContentObject.dataType}' because parent node is undefined. Please report this error if you are seeing this.`);
            } else {
              if (dataTypeAttribute.value === "item") {
                result.linkedItems.push(linkItemContentObject);
                yield resolvers2.contentItemResolverAsync(parserHelper.convertToParserElement(element), linkItemContentObject.dataCodename, linkedItemIndex.index, parserHelper.getLinkedItem(linkedItems, linkItemContentObject.dataCodename));
                linkedItemIndex.increment();
              } else {
                console.warn(`Rich text element contains object with unsupported data type '${dataTypeAttribute.value}'`);
              }
            }
          } else if (element.nodeName.toLowerCase() === parserConfiguration.linkElementData.nodeName.toLowerCase()) {
            const dataItemIdAttribute = element.attributes.getNamedItem(parserConfiguration.linkElementData.dataItemId);
            if (dataItemIdAttribute) {
              const linkObject = {
                dataItemId: dataItemIdAttribute ? dataItemIdAttribute.value : ""
              };
              result.links.push(linkObject);
              const linkText = element.innerHTML;
              yield resolvers2.urlResolverAsync(parserHelper.convertToParserElement(element), linkObject.dataItemId, linkText, parserHelper.tryGetLink(mainRichTextElement, linkedItems, linkObject.dataItemId));
            }
          } else if (element.nodeName.toLowerCase() === parserConfiguration.imageElementData.nodeName.toLowerCase()) {
            const dataImageIdAttribute = element.attributes.getNamedItem(parserConfiguration.imageElementData.dataImageId);
            if (dataImageIdAttribute) {
              const imageObj = {
                imageId: dataImageIdAttribute.value
              };
              result.images.push(imageObj);
              yield resolvers2.imageResolverAsync(parserHelper.convertToParserElement(element), imageObj.imageId, parserHelper.tryGetImage(mainRichTextElement, linkedItems, imageObj.imageId));
            }
          } else {
            yield resolvers2.genericElementResolverAsync(parserHelper.convertToParserElement(element));
          }
          if (element.children && element.children.length > 0) {
            yield this.processRichTextElementAsync(mainRichTextElement, resolvers2, element.children, result, linkedItems, linkedItemIndex, parentElement);
          }
        }
      }
      return result;
    });
  }
  createWrapperElement(html) {
    const element = document.createElement(parserConfiguration.linkedItemWrapperElem);
    element.innerHTML = html;
    return element;
  }
};
var asyncBrowserParser = new AsyncBrowserParser();

// node_modules/@kontent-ai/delivery-sdk/dist/es6/parser/implementation/browser-parser.class.js
var BrowserParser = class {
  parse(html, mainRichTextElement, resolvers2, linkedItems) {
    return this.parseInternal(mainRichTextElement, resolvers2, html, linkedItems, new ParsedItemIndexReferenceWrapper(0), null);
  }
  parseInternal(mainRichTextElement, resolvers2, html, linkedItems, linkedItemIndex, parentElement) {
    const rootElement = this.createWrapperElement(html);
    const result = this.processRichTextElement(mainRichTextElement, resolvers2, rootElement.children, {
      links: [],
      linkedItems: [],
      images: []
    }, linkedItems, linkedItemIndex, parentElement);
    return {
      componentCodenames: result.linkedItems.filter((m) => m.itemType === "component").map((m) => m.dataCodename),
      linkedItemCodenames: result.linkedItems.filter((m) => m.itemType === "linkedItem").map((m) => m.dataCodename),
      result: rootElement.innerHTML
    };
  }
  processRichTextElement(mainRichTextElement, resolvers2, htmlCollection, result, linkedItems, linkedItemIndex, parentElement) {
    if (!htmlCollection || htmlCollection.length === 0) {
    } else {
      for (let i = 0; i < htmlCollection.length; i++) {
        const element = htmlCollection[i];
        resolvers2.elementResolver(parserHelper.convertToParserElement(element));
        const typeAttribute = element.attributes ? element.attributes.getNamedItem("type") : void 0;
        if (element.attributes && typeAttribute && typeAttribute.value && typeAttribute.value.toLowerCase() === parserConfiguration.modularContentElementData.type.toLowerCase()) {
          const dataCodenameAttribute = element.attributes.getNamedItem(parserConfiguration.modularContentElementData.dataCodename);
          const dataTypeAttribute = element.attributes.getNamedItem(parserConfiguration.modularContentElementData.dataType);
          if (!dataTypeAttribute) {
            throw Error("Missing data type attribute. This is likely an error caused by invalid response.");
          }
          const relAttribute = element.attributes.getNamedItem(parserConfiguration.modularContentElementData.relAttribute);
          let itemType = "linkedItem";
          if (relAttribute && relAttribute.value === parserConfiguration.modularContentElementData.componentRel) {
            itemType = "component";
          }
          const linkItemContentObject = {
            dataCodename: dataCodenameAttribute ? dataCodenameAttribute.value : "",
            dataType: dataTypeAttribute ? dataTypeAttribute.value : "",
            itemType
          };
          const elementParent = element.parentElement;
          if (!elementParent) {
            console.warn(`Could not replace linked item '${linkItemContentObject.dataCodename}' of '${linkItemContentObject.dataType}' because parent node is undefined. Please report this error if you are seeing this.`);
          } else {
            if (dataTypeAttribute.value === "item") {
              result.linkedItems.push(linkItemContentObject);
              resolvers2.contentItemResolver(parserHelper.convertToParserElement(element), linkItemContentObject.dataCodename, linkedItemIndex.index, parserHelper.getLinkedItem(linkedItems, linkItemContentObject.dataCodename));
              linkedItemIndex.increment();
            } else {
              console.warn(`Rich text element contains object with unsupported data type '${dataTypeAttribute.value}'`);
            }
          }
        } else if (element.nodeName.toLowerCase() === parserConfiguration.linkElementData.nodeName.toLowerCase()) {
          const dataItemIdAttribute = element.attributes.getNamedItem(parserConfiguration.linkElementData.dataItemId);
          if (dataItemIdAttribute) {
            const linkObject = {
              dataItemId: dataItemIdAttribute ? dataItemIdAttribute.value : ""
            };
            result.links.push(linkObject);
            const linkText = element.innerHTML;
            resolvers2.urlResolver(parserHelper.convertToParserElement(element), linkObject.dataItemId, linkText, parserHelper.tryGetLink(mainRichTextElement, linkedItems, linkObject.dataItemId));
          }
        } else if (element.nodeName.toLowerCase() === parserConfiguration.imageElementData.nodeName.toLowerCase()) {
          const dataImageIdAttribute = element.attributes.getNamedItem(parserConfiguration.imageElementData.dataImageId);
          if (dataImageIdAttribute) {
            const imageObj = {
              imageId: dataImageIdAttribute.value
            };
            result.images.push(imageObj);
            resolvers2.imageResolver(parserHelper.convertToParserElement(element), imageObj.imageId, parserHelper.tryGetImage(mainRichTextElement, linkedItems, imageObj.imageId));
          }
        } else {
          resolvers2.genericElementResolver(parserHelper.convertToParserElement(element));
        }
        if (element.children && element.children.length > 0) {
          this.processRichTextElement(mainRichTextElement, resolvers2, element.children, result, linkedItems, linkedItemIndex, parentElement);
        }
      }
    }
    return result;
  }
  createWrapperElement(html) {
    const element = document.createElement(parserConfiguration.linkedItemWrapperElem);
    element.innerHTML = html;
    return element;
  }
};
var browserParser = new BrowserParser();

// node_modules/@kontent-ai/delivery-sdk/dist/es6/resolvers/property-name/camel-case-property-name-resolver.class.js
var camelCasePropertyNameResolver = (contentType, element) => {
  return textHelper.addUnderscoreWhenStarsWithNumber(textHelper.removeZeroWidthCharacters(toCamelCase2(element)));
};
function toCamelCase2(str) {
  str = str.replace(textHelper.getPropertyNameRegex(), (_, c) => c ? c.toUpperCase() : "");
  return str.substring(0, 1).toLowerCase() + str.substring(1);
}

// node_modules/@kontent-ai/delivery-sdk/dist/es6/resolvers/property-name/pascal-case-property-name-resolver.class.js
var pascalCasePropertyNameResolver = (contentType, element) => {
  return textHelper.addUnderscoreWhenStarsWithNumber(textHelper.removeZeroWidthCharacters(toPascalCase(element)));
};
function toPascalCase(str) {
  str = str.replace(textHelper.getPropertyNameRegex(), (_, c) => c ? c.toUpperCase() : "");
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}

// node_modules/@kontent-ai/delivery-sdk/dist/es6/resolvers/property-name/snake-case-property-name-resolver.class.js
var snakeCasePropertyNameResolver = (contentType, element) => {
  return textHelper.addUnderscoreWhenStarsWithNumber(textHelper.removeZeroWidthCharacters(toSnakeCase(element))).toLowerCase();
};
function toSnakeCase(str) {
  str = str.replace(textHelper.getPropertyNameRegex(), (_, c) => "_" + (c ? c.toLowerCase() : ""));
  return removeEndUnderscore(removeStartUnderscore(str));
}
function removeStartUnderscore(str) {
  if (!str.startsWith("_")) {
    return str;
  }
  return str.substring(1);
}
function removeEndUnderscore(str) {
  if (!str.endsWith("_")) {
    return str;
  }
  return str.slice(0, -1);
}

// node_modules/@kontent-ai/delivery-sdk/dist/es6/resolvers/rich-text/base/base-rich-text-resolver.js
var BaseRichTextResolver = class {
  constructor(defaultParser, parser) {
    this.defaultParser = defaultParser;
    this.parser = parser;
  }
  getParser() {
    if (this.parser) {
      return this.parser;
    }
    return this.defaultParser;
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/resolvers/rich-text/sync/rich-text-html-resolver.js
var RichTextHtmlResolver = class extends BaseRichTextResolver {
  constructor(parser) {
    super(browserParser, parser);
  }
  resolveRichText(input) {
    return this.resolveRichTextInternal(input.element.value, input);
  }
  resolveRichTextInternal(html, input) {
    var _a;
    const parsedResult = super.getParser().parse(html, input.element, {
      elementResolver: (element) => {
      },
      contentItemResolver: (element, itemCodename, linkedItemIndex, linkedItem) => {
        var _a2;
        const parentElement = element.parentElement;
        if (parentElement) {
          const resolvedItemHtml = input.contentItemResolver ? (_a2 = input.contentItemResolver(itemCodename, linkedItem).contentItemHtml) !== null && _a2 !== void 0 ? _a2 : "" : "";
          const innerHtml = this.resolveRichTextInternal(resolvedItemHtml, input).html;
          if (input.preserveResolvedObjectTags === true) {
            element.setInnerHtml(innerHtml);
          } else {
            element.setOuterHtml(innerHtml);
          }
          element.setAttribute(parserHelper.sdkResolvedAttributeName, "1");
        }
      },
      genericElementResolver: (element) => {
      },
      imageResolver: (element, imageId, image) => {
        const imageResult = input.imageResolver ? input.imageResolver(imageId, image) : void 0;
        if (imageResult === null || imageResult === void 0 ? void 0 : imageResult.imageHtml) {
          element.setOuterHtml(imageResult.imageHtml);
        } else if (imageResult === null || imageResult === void 0 ? void 0 : imageResult.imageUrl) {
          element.setAttribute(parserConfiguration.imageElementData.srcAttribute, imageResult.imageUrl);
        }
      },
      urlResolver: (element, linkId, linkText, link) => {
        if (input.urlResolver) {
          const urlResult = input.urlResolver(linkId, linkText, link);
          if (urlResult === null || urlResult === void 0 ? void 0 : urlResult.linkHtml) {
            element.setOuterHtml(urlResult.linkHtml);
          } else if (urlResult === null || urlResult === void 0 ? void 0 : urlResult.linkUrl) {
            element.setAttribute("href", urlResult.linkUrl);
          }
        }
      }
    }, (_a = input.linkedItems) !== null && _a !== void 0 ? _a : []);
    return {
      componentCodenames: parsedResult.componentCodenames,
      linkedItemCodenames: parsedResult.linkedItemCodenames,
      html: parsedResult.result
    };
  }
};
var createRichTextHtmlResolver = (parser) => new RichTextHtmlResolver(parser);

// node_modules/@kontent-ai/delivery-sdk/dist/es6/resolvers/rich-text/sync/rich-text-object-resolver.js
var RichTextObjectResolver = class extends BaseRichTextResolver {
  constructor(parser) {
    super(browserParser, parser);
    this.sdkIdAttributeName = "sdk-elem-id";
    this.rootId = "root";
    this.defaultWrapTag = "div";
  }
  resolveRichText(input) {
    var _a;
    const result = this.resolveRichTextInternal(input.element.value, input, {
      type: "root",
      attributes: [],
      children: [],
      data: {},
      tag: (_a = input.wrapperTag) !== null && _a !== void 0 ? _a : this.defaultWrapTag,
      _sdkElemId: this.rootId
    });
    if (input.cleanSdkIds === true) {
      this.cleanSdkIds(result);
    }
    return {
      data: result
    };
  }
  resolveRichTextInternal(html, input, result) {
    var _a;
    super.getParser().parse(html, input.element, {
      elementResolver: (element) => {
        element.setAttribute(this.sdkIdAttributeName, guidHelper.genereateGuid());
      },
      contentItemResolver: (element, itemCodename, linkedItemIndex, linkedItem) => {
        const data = {
          codename: itemCodename,
          item: linkedItem
        };
        const parentSdkId = this.getSdkIdFromElement(element.parentElement);
        const parentItem = this.findItemWithSdkId(parentSdkId, result);
        if (parentItem) {
          parentItem.children.push({
            type: "linkedItem",
            attributes: this.getAttributes(element),
            tag: element.tag.toLowerCase(),
            data,
            children: [],
            _sdkElemId: this.getSdkIdFromElement(element)
          });
        }
      },
      genericElementResolver: (element) => {
        var _a2, _b;
        const data = {
          text: (_a2 = element.text) !== null && _a2 !== void 0 ? _a2 : "",
          html: (_b = element.html) !== null && _b !== void 0 ? _b : ""
        };
        const parentSdkId = this.getSdkIdFromElement(element.parentElement);
        const parentItem = this.findItemWithSdkId(parentSdkId, result);
        if (parentItem) {
          parentItem.children.push({
            type: "htmlElement",
            attributes: this.getAttributes(element),
            tag: element.tag.toLowerCase(),
            data,
            children: [],
            _sdkElemId: this.getSdkIdFromElement(element)
          });
        }
      },
      imageResolver: (element, imageId, image) => {
        const data = {
          imageId,
          image
        };
        const parentSdkId = this.getSdkIdFromElement(element.parentElement);
        const parentItem = this.findItemWithSdkId(parentSdkId, result);
        if (parentItem) {
          parentItem.children.push({
            type: "image",
            attributes: this.getAttributes(element),
            tag: element.tag.toLowerCase(),
            data,
            children: [],
            _sdkElemId: this.getSdkIdFromElement(element)
          });
        }
      },
      urlResolver: (element, linkId, linkText, link) => {
        const data = {
          linkId,
          linkText,
          link
        };
        const parentSdkId = this.getSdkIdFromElement(element.parentElement);
        const parentItem = this.findItemWithSdkId(parentSdkId, result);
        if (parentItem) {
          parentItem.children.push({
            type: "link",
            attributes: this.getAttributes(element),
            tag: element.tag.toLowerCase(),
            data,
            children: [],
            _sdkElemId: this.getSdkIdFromElement(element)
          });
        }
      }
    }, (_a = input.linkedItems) !== null && _a !== void 0 ? _a : []);
    return result;
  }
  findItemWithSdkId(sdkId, item) {
    if (item._sdkElemId === sdkId) {
      return item;
    }
    for (const child of item.children) {
      const foundItem = this.findItemWithSdkId(sdkId, child);
      if (foundItem) {
        return foundItem;
      }
    }
    return void 0;
  }
  getAttributes(element) {
    var _a;
    return (_a = element === null || element === void 0 ? void 0 : element.attributes) !== null && _a !== void 0 ? _a : [];
  }
  getSdkIdFromElement(element) {
    var _a, _b;
    if (!element) {
      return this.rootId;
    }
    const value = (_b = (_a = element.attributes.find((m) => m.name === this.sdkIdAttributeName)) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : this.rootId;
    return value;
  }
  cleanSdkIds(item) {
    item.attributes = item.attributes.filter((m) => m.name !== this.sdkIdAttributeName);
    item._sdkElemId = "";
    for (const child of item.children) {
      this.cleanSdkIds(child);
    }
  }
};
var createRichTextObjectResolver = (parser) => new RichTextObjectResolver(parser);

// node_modules/@kontent-ai/delivery-sdk/dist/es6/resolvers/rich-text/sync/rich-text-json-resolver.js
var RichTextJsonResolver = class extends BaseRichTextResolver {
  constructor(parser) {
    super(browserParser, parser);
  }
  resolveRichText(input) {
    const objectResult = createRichTextObjectResolver(this.getParser()).resolveRichText(input).data;
    return {
      json: JSON.stringify(objectResult)
    };
  }
};
var createRichTextJsonResolver = (parser) => new RichTextJsonResolver(parser);

// node_modules/@kontent-ai/delivery-sdk/dist/es6/resolvers/rich-text/base/base-async-rich-text-resolver.js
var BaseAsyncRichTextResolver = class {
  constructor(defaultParser, parser) {
    this.defaultParser = defaultParser;
    this.parser = parser;
  }
  getAsyncParser() {
    if (this.parser) {
      return this.parser;
    }
    return this.defaultParser;
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/resolvers/rich-text/async/async-rich-text-html-resolver.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AsyncRichTextHtmlResolver = class extends BaseAsyncRichTextResolver {
  constructor(parser) {
    super(asyncBrowserParser, parser);
  }
  resolveRichTextAsync(input) {
    return __awaiter6(this, void 0, void 0, function* () {
      return yield this.resolveRichTextInternalAsync(input.element.value, input);
    });
  }
  resolveRichTextInternalAsync(html, input) {
    const _super = Object.create(null, {
      getAsyncParser: { get: () => super.getAsyncParser }
    });
    var _a;
    return __awaiter6(this, void 0, void 0, function* () {
      const parsedResult = yield _super.getAsyncParser.call(this).parseAsync(html, input.element, {
        elementResolverAsync: (element) => __awaiter6(this, void 0, void 0, function* () {
        }),
        contentItemResolverAsync: (element, itemCodename, linkedItemIndex, linkedItem) => __awaiter6(this, void 0, void 0, function* () {
          var _b;
          const parentElement = element.parentElement;
          if (parentElement) {
            const resolvedItemHtml = input.contentItemResolverAsync ? (_b = (yield input.contentItemResolverAsync(itemCodename, linkedItem)).contentItemHtml) !== null && _b !== void 0 ? _b : "" : "";
            const innerHtml = (yield this.resolveRichTextInternalAsync(resolvedItemHtml, input)).html;
            if (input.preserveResolvedObjectTags === true) {
              element.setInnerHtml(innerHtml);
            } else {
              element.setOuterHtml(innerHtml);
            }
            element.setAttribute(parserHelper.sdkResolvedAttributeName, "1");
          }
        }),
        genericElementResolverAsync: (element) => __awaiter6(this, void 0, void 0, function* () {
        }),
        imageResolverAsync: (element, imageId, image) => __awaiter6(this, void 0, void 0, function* () {
          const imageResult = input.imageResolverAsync ? yield input.imageResolverAsync(imageId, image) : void 0;
          if (imageResult === null || imageResult === void 0 ? void 0 : imageResult.imageHtml) {
            element.setOuterHtml(imageResult.imageHtml);
          } else if (imageResult === null || imageResult === void 0 ? void 0 : imageResult.imageUrl) {
            element.setAttribute(parserConfiguration.imageElementData.srcAttribute, imageResult.imageUrl);
          }
        }),
        urlResolverAsync: (element, linkId, linkText, link) => __awaiter6(this, void 0, void 0, function* () {
          if (input.urlResolverAsync) {
            const urlResult = yield input.urlResolverAsync(linkId, linkText, link);
            if (urlResult === null || urlResult === void 0 ? void 0 : urlResult.linkHtml) {
              element.setOuterHtml(urlResult.linkHtml);
            } else if (urlResult === null || urlResult === void 0 ? void 0 : urlResult.linkUrl) {
              element.setAttribute("href", urlResult.linkUrl);
            }
          }
        })
      }, (_a = input.linkedItems) !== null && _a !== void 0 ? _a : []);
      return {
        componentCodenames: parsedResult.componentCodenames,
        linkedItemCodenames: parsedResult.linkedItemCodenames,
        html: parsedResult.result
      };
    });
  }
};
var createAsyncRichTextHtmlResolver = (parser) => new AsyncRichTextHtmlResolver(parser);

// node_modules/@kontent-ai/delivery-sdk/dist/es6/images/image-url-transformation-builder.js
var ImageUrlTransformationBuilder = class {
  constructor(imageUrl) {
    this.imageUrl = imageUrl;
    this.queryParams = [];
    this.automaticFormatValue = "format";
  }
  /**
   * Used to add custom parameters to existing query string
   * @param param Parameter (may or may not include value)
   */
  withCustomParam(param) {
    this.queryParams.push(new Parameters2.CustomParameter(param));
    return this;
  }
  /**
   * The dpr transformation is used to serve correctly sized images for devices that expose a device pixel ratio.
   * @param dpr A required DPR value.
   */
  withDpr(dpr) {
    this.queryParams.push(new Parameters2.QueryParameter("dpr", dpr.toString()));
    return this;
  }
  /**
   * Applies the crop transformation that removes pixels from an image outside the specified rectangle.
   * @param x Rectangle offset on the X-axis.
   * @param y Rectangle offset on the Y-axis.
   * @param width Rectangle width.
   * @param height Rectangle height.
   */
  withRectangleCrop(x, y, width, height) {
    this.queryParams.push(new Parameters2.QueryParameter("rect", [x, y, width, height].join(",")));
    return this;
  }
  /**
   * Applies the crop transformation centered on the specified point.
   * @param x Focal point X coordinate.
   * @param y Focal point Y coordinate.
   * @param z Zoom of the transformation.
   */
  withFocalPointCrop(x, y, z) {
    this.withFitMode("crop");
    this.queryParams.push(new Parameters2.QueryParameter("crop", "focalpoint"));
    this.queryParams.push(new Parameters2.QueryParameter("fp-x", x.toString()));
    this.queryParams.push(new Parameters2.QueryParameter("fp-y", y.toString()));
    this.queryParams.push(new Parameters2.QueryParameter("fp-z", z.toString()));
    return this;
  }
  /**
   * Enables WebP image support.
   * @param compression Specifies the lossy or lossless compression.
   */
  withAutomaticFormat(backupFormat) {
    this.queryParams.push(new Parameters2.QueryParameter("auto", this.automaticFormatValue));
    if (backupFormat) {
      this.withFormat(backupFormat);
    }
    return this;
  }
  /**
   * The fit transformation controls how the output image is fit to its target dimensions after resizing.
   * @param fitMode Specifies the mode for the transformation.
   */
  withFitMode(fitMode) {
    this.queryParams.push(new Parameters2.QueryParameter("fit", fitMode));
    return this;
  }
  /**
   * Specifies the compression mode for the WebP image transformations.
   * @param compression Specifies the lossy or lossless compression.
   */
  withCompression(compression) {
    this.queryParams.push(new Parameters2.QueryParameter("lossless", compression === "lossless" ? "true" : "false"));
    return this;
  }
  /**
   * Applies the quality parameter that enables control over the compression level for lossy file-formatted images.
   * @param quality The required quality of the image.
   */
  withQuality(quality) {
    this.queryParams.push(new Parameters2.QueryParameter("q", quality.toString()));
    return this;
  }
  /**
   * The format transformation enables the source image to be converted (a.k.a., "transcoded") from
   * one encoded format to another. This is very useful when the source image has been saved in a sub-optimal
   * file format that hinders performance.
   * @param format Target image file type.
   */
  withFormat(format) {
    this.queryParams.push(new Parameters2.QueryParameter("fm", format));
    return this;
  }
  /**
   * The height transformation enables dynamic height resizing based on pixels and percent values.
   * @param height A required image height.
   */
  withHeight(height) {
    this.queryParams.push(new Parameters2.QueryParameter("h", height.toString()));
    return this;
  }
  /**
   * The width transformation enables dynamic width resizing based on pixels and percent values.
   * @param width A required image width.
   */
  withWidth(width) {
    this.queryParams.push(new Parameters2.QueryParameter("w", width.toString()));
    return this;
  }
  /**
   * Gets params applied to image
   */
  getParams() {
    return this.queryParams;
  }
  /**
   * Gets query string part of the image URL
   */
  getQueryString() {
    let query = "";
    this.queryParams.forEach((filter2) => {
      if (query.indexOf("?") > -1) {
        query = query + "&" + filter2.getParam();
      } else {
        query = query + "?" + filter2.getParam();
      }
    });
    return query;
  }
  /**
   * Gets full transformed url to image with parameters
   */
  getUrl() {
    return this.imageUrl + this.getQueryString();
  }
};

// node_modules/@kontent-ai/delivery-sdk/dist/es6/images/image-url-transformation-builder.factory.js
function transformImageUrl(url) {
  return new ImageUrlTransformationBuilder(url);
}
export {
  AsyncBrowserParser,
  AsyncRichTextHtmlResolver,
  BaseQuery,
  BrowserParser,
  CodenameHelper,
  DeliveryClient,
  DeliveryError,
  DeliveryUrlHelper,
  ElementMapper,
  ElementQuery,
  ElementType,
  EnumHelper,
  Filters,
  GenericElementMapper,
  GuidHelper,
  ImageUrlTransformationBuilder,
  InitializeSyncQuery,
  ItemMapper,
  ItemsFeedQuery,
  LanguageMapper,
  LanguagesQuery,
  LinkedItemsHelper,
  MappingService,
  MultipleItemsQuery,
  MultipleTypeQuery,
  Parameters2 as Parameters,
  ParsedItemIndexReferenceWrapper,
  ParserHelper,
  QueryService,
  RichTextHtmlResolver,
  RichTextJsonResolver,
  RichTextObjectResolver,
  SingleItemQuery,
  SingleTypeQuery,
  SyncChangesQuery,
  SyncMapper,
  TaxonomiesQuery,
  TaxonomyMapper,
  TaxonomyQuery,
  TextHelper,
  TypeMapper,
  asyncBrowserParser,
  browserParser,
  camelCasePropertyNameResolver,
  codenameHelper,
  continuationTokenHeaderName,
  createAsyncRichTextHtmlResolver,
  createDeliveryClient,
  createRichTextHtmlResolver,
  createRichTextJsonResolver,
  createRichTextObjectResolver,
  deliveryUrlHelper,
  enumHelper,
  guidHelper,
  linkedItemsHelper,
  parserConfiguration,
  parserHelper,
  pascalCasePropertyNameResolver,
  sdkInfo,
  sdkVersionHeader,
  snakeCasePropertyNameResolver,
  staleContentHeaderName,
  textHelper,
  transformImageUrl,
  waitForLoadingNewContentHeader
};
//# sourceMappingURL=@kontent-ai_delivery-sdk.js.map
